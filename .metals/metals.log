[0m2021.03.20 17:26:48 INFO  Started: Metals version 0.10.0 in workspace '/home/nevermind/scalademo' for client vscode 1.54.3.[0m
[0m2021.03.20 17:26:49 INFO  time: initialize in 1.58s[0m
[0m2021.03.20 17:26:50 WARN  Build server is not auto-connectable.[0m
[0m2021.03.20 17:26:50 WARN  no build tool detected in workspace '/home/nevermind/scalademo'. The most common cause for this problem is that the editor was opened in the wrong working directory, for example if you use sbt then the workspace directory should contain build.sbt. [0m
[0m2021.03.20 17:26:51 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
[0m2021.03.20 17:26:55 INFO  no build target: using presentation compiler with only scala-library: 2.12.13[0m
object Main extends App {
  println("Hello, World!")
}
object Main extends App {
  println("Hello, World!")
}
object Main extends App {
  println("Hello, World!")
}
[0m2021.03.20 17:26:57 INFO  time: code lens generation in 2.67s[0m
object Main extends App {
  println("Hello, World!")
}
[0m2021.03.20 17:26:57 INFO  time: code lens generation in 5.8s[0m
object Main extends App {
  println("Hello, World!")
}
object Main extends App {
  println("Hello, World!")
}
object Main extends App {
  println("Hello, World!")
}
object Main extends App {
  println("Hello, World!")
}
object Main extends App {
  println("Hello, World!")
}
object Main extends App {
  println("Hello, World!")
}
object Main extends App {
  println("Hello, World!")
}
object Main extends App {
  println("Hello, World!")
}
object Main extends App {
  println("Hello, World!")
}
object Main extends App {
  println("Hello, World!")
}
object Main extends App {
  println("Hello, World!")
}
object Main extends App {
  println("Hello, World!")
}
[0m2021.03.20 17:27:28 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
object Main extends App {
  println("Hello, Austria!")
}
[0m2021.03.20 17:28:05 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/build.sbt[0m

// The simplest possible sbt build file is just one line:

scalaVersion := "2.13.3"
// That is, to create a valid sbt build, all you've got to do is define the
// version of Scala you'd like your project to use.

// ============================================================================

// Lines like the above defining `scalaVersion` are called "settings". Settings
// are key/value pairs. In the case of `scalaVersion`, the key is "scalaVersion"
// and the value is "2.13.3"

// It's possible to define many kinds of settings, such as:

name := "hello-world"
organization := "ch.epfl.scala"
version := "1.0"

// Note, it's not required for you to define these three settings. These are
// mostly only necessary if you intend to publish your library's binaries on a
// place like Sonatype or Bintray.


// Want to use a published library in your project?
// You can define other libraries as dependencies in your build like this:

libraryDependencies += "org.scala-lang.modules" %% "scala-parser-combinators" % "1.1.2"

// Here, `libraryDependencies` is a set of dependencies, and by using `+=`,
// we're adding the scala-parser-combinators dependency to the set of dependencies
// that sbt will go and fetch when it starts up.
// Now, in any Scala file, you can import classes, objects, etc., from
// scala-parser-combinators with a regular import.

// TIP: To find the "dependency" that you need to add to the
// `libraryDependencies` set, which in the above example looks like this:

// "org.scala-lang.modules" %% "scala-parser-combinators" % "1.1.2"

// You can use Scaladex, an index of all known published Scala libraries. There,
// after you find the library you want, you can just copy/paste the dependency
// information that you need into your build file. For example, on the
// scala/scala-parser-combinators Scaladex page,
// https://index.scala-lang.org/scala/scala-parser-combinators, you can copy/paste
// the sbt dependency from the sbt box on the right-hand side of the screen.

// IMPORTANT NOTE: while build files look _kind of_ like regular Scala, it's
// important to note that syntax in *.sbt files doesn't always behave like
// regular Scala. For example, notice in this build file that it's not required
// to put our settings into an enclosing object or class. Always remember that
// sbt is a bit different, semantically, than vanilla Scala.

// ============================================================================

// Most moderately interesting Scala projects don't make use of the very simple
// build file style (called "bare style") used in this build.sbt file. Most
// intermediate Scala projects make use of so-called "multi-project" builds. A
// multi-project build makes it possible to have different folders which sbt can
// be configured differently for. That is, you may wish to have different
// dependencies or different testing frameworks defined for different parts of
// your codebase. Multi-project builds make this possible.

// Here's a quick glimpse of what a multi-project build looks like for this
// build, with only one "subproject" defined, called `root`:

// lazy val root = (project in file(".")).
//   settings(
//     inThisBuild(List(
//       organization := "ch.epfl.scala",
//       scalaVersion := "2.13.3"
//     )),
//     name := "hello-world"
//   )

// To learn more about multi-project builds, head over to the official sbt
// documentation at http://www.scala-sbt.org/documentation.html

object Main extends App {
  println("Hello, Austria!")
}
MÃ¤rz 20, 2021 5:32:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 81
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
object Main extends App {
  println("Hello, Austria!")
}
[0m2021.03.20 17:33:07 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
object Main extends App {
  println("Hello, Austria!")
  println(200 + 10000000000000000000000)
}
MÃ¤rz 20, 2021 5:33:08 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 10000000000000000000000)
}
MÃ¤rz 20, 2021 5:33:23 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 10000000000000000000000)
}
MÃ¤rz 20, 2021 5:33:24 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 10000000000000000000000)
}
MÃ¤rz 20, 2021 5:33:24 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 10000000000000000000000)
}
MÃ¤rz 20, 2021 5:33:24 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 10000000000000000000000)
}
MÃ¤rz 20, 2021 5:33:24 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

MÃ¤rz 20, 2021 5:33:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 176
object Main extends App {
  println("Hello, Austria!")
  println(200 + 10000000000000000000000)
}
MÃ¤rz 20, 2021 5:33:25 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 10000000000000000000000)
}
MÃ¤rz 20, 2021 5:33:25 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 10000000000000000000000)
}
MÃ¤rz 20, 2021 5:33:25 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 10000000000000000000000)
}
MÃ¤rz 20, 2021 5:33:26 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 10000000000000000000000)
}
MÃ¤rz 20, 2021 5:33:26 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 10000000000000000000000)
}
MÃ¤rz 20, 2021 5:33:26 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 10000000000000000000000)
}
MÃ¤rz 20, 2021 5:33:26 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 10000000000000000000000)
}
MÃ¤rz 20, 2021 5:33:26 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 10000000000000000000000)
}
MÃ¤rz 20, 2021 5:33:26 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 10000000000000000000000)
}
MÃ¤rz 20, 2021 5:33:27 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 10000000000000000000000)
}
MÃ¤rz 20, 2021 5:33:27 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 10000000000000000000000)
}
MÃ¤rz 20, 2021 5:33:27 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 10000000000000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

[0m2021.03.20 17:33:28 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
object Main extends App {
  println("Hello, Austria!")
  println(200 + 100000000000000)
}
MÃ¤rz 20, 2021 5:33:28 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 100000000000000)
}
MÃ¤rz 20, 2021 5:33:30 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 100000000000000)
}
MÃ¤rz 20, 2021 5:33:30 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 100000000000000)
}
MÃ¤rz 20, 2021 5:33:30 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 100000000000000)
}
MÃ¤rz 20, 2021 5:33:31 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 100000000000000)
}
MÃ¤rz 20, 2021 5:33:31 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 100000000000000)
}
MÃ¤rz 20, 2021 5:33:31 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 100000000000000)
}
MÃ¤rz 20, 2021 5:33:31 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 100000000000000)
}
MÃ¤rz 20, 2021 5:33:32 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 100000000000000)
}
MÃ¤rz 20, 2021 5:33:32 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 100000000000000)
}
MÃ¤rz 20, 2021 5:33:32 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 100000000000000)
}
MÃ¤rz 20, 2021 5:33:33 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 100000000000000)
}
MÃ¤rz 20, 2021 5:33:33 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 100000000000000)
}
MÃ¤rz 20, 2021 5:33:33 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 100000000000000)
}
MÃ¤rz 20, 2021 5:33:33 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 100000000000000)
}
MÃ¤rz 20, 2021 5:33:33 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 100000000000000)
}
MÃ¤rz 20, 2021 5:33:33 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 100000000000000)
}
MÃ¤rz 20, 2021 5:33:34 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 100000000000000)
}
MÃ¤rz 20, 2021 5:33:34 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 100000000000000)
}
MÃ¤rz 20, 2021 5:33:34 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 100000000000000)
}
MÃ¤rz 20, 2021 5:33:34 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

object Main extends App {
  println("Hello, Austria!")
  println(200 + 100000000000000)
}
MÃ¤rz 20, 2021 5:33:35 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala:3: error: integer number too large
  println(200 + 100000000000000)
                ^
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:16)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.Reporter.syntaxError(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter.syntaxError$(Reporter.scala:17)
	at scala.meta.internal.parsers.Reporter$$anon$1.syntaxError(Reporter.scala:22)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$literal$1(ScalametaParser.scala:1949)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.literal(ScalametaParser.scala:1942)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2785)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsOrPrefixExpr(ScalametaParser.scala:2920)
	at scala.meta.internal.parsers.ScalametaParser.loop$4(ScalametaParser.scala:2710)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2740)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.argumentExpr(ScalametaParser.scala:2949)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$3(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.partOrEllipsis$1(ScalametaParser.scala:1337)
	at scala.meta.internal.parsers.ScalametaParser.tokenSeparated(ScalametaParser.scala:1340)
	at scala.meta.internal.parsers.ScalametaParser.commaSeparated(ScalametaParser.scala:1349)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$argumentExprsWithUsing$1(ScalametaParser.scala:2965)
	at scala.meta.internal.parsers.ScalametaParser.inParens(ScalametaParser.scala:695)
	at scala.meta.internal.parsers.ScalametaParser.argumentExprsWithUsing(ScalametaParser.scala:2956)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$3(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExprRest$1(ScalametaParser.scala:2905)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.simpleExprRest(ScalametaParser.scala:2877)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$5(ScalametaParser.scala:2823)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2823)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4876)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.semanticdb.scalac.ParseOps$XtensionCompilationUnitSource.toSource(ParseOps.scala:17)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

[0m2021.03.20 17:33:36 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)
}
[0m2021.03.20 17:40:33 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
object Main extends App {
  //println("Hello, Austria!")
  //println(200 + 1000000)
  def name: String = System.getProperty("user.name")
  println("Hello, " + name + "!")
}

MÃ¤rz 20, 2021 5:40:51 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
MÃ¤rz 20, 2021 5:40:52 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
MÃ¤rz 20, 2021 5:40:56 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
MÃ¤rz 20, 2021 5:40:59 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
MÃ¤rz 20, 2021 5:41:01 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
MÃ¤rz 20, 2021 5:41:01 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
MÃ¤rz 20, 2021 5:41:01 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
MÃ¤rz 20, 2021 5:41:02 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
[0m2021.03.20 17:43:53 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}

object Main extends App {
  //println("Hello, Austria!")
  //println(200 + 1000000)
  def name: String = System.getProperty("user.name")
  println("Hello, " + name + "!")
}

MÃ¤rz 20, 2021 5:44:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 417
[0m2021.03.20 17:44:25 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}

object Main extends App {
  println("Hello, Austria!")
  println(200 + 1000000)

  def name: String = System.getProperty("user.name")
  println("Hello, " + name + "!")

  val greeter = new Greeter("Hello, ", "!")
  greeter.greet("Scala developer")
}

[0m2021.03.20 17:45:33 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
MÃ¤rz 20, 2021 5:45:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 525
MÃ¤rz 20, 2021 5:45:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 527
[0m2021.03.20 17:46:31 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}

object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)
}

[0m2021.03.20 17:47:10 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
MÃ¤rz 20, 2021 5:47:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 673
[0m2021.03.20 17:47:34 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}

// will a command start a rebuild?
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)
}

[0m2021.03.20 17:47:43 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)
}

[0m2021.03.20 17:52:14 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)
}

[0m2021.03.20 17:52:37 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)
}

[0m2021.03.20 17:52:56 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/
}

[0m2021.03.20 17:53:28 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter

class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/
}

[0m2021.03.20 17:53:57 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter

class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?
}

MÃ¤rz 20, 2021 5:54:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 903
MÃ¤rz 20, 2021 5:54:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 985
[0m2021.03.20 17:54:37 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?
}

MÃ¤rz 20, 2021 5:54:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1017
[0m2021.03.20 17:55:24 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
[0m2021.03.20 17:57:36 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))
}

[0m2021.03.20 17:59:18 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786
}

[0m2021.03.20 18:01:33 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786
}

[0m2021.03.20 18:01:57 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  val point1 = new Point(2, 3)
  println(point1.x) // 2
  println(point1) // prints (2, 3)
}

/*
 * Scala (https://www.scala-lang.org)
 *
 * Copyright EPFL and Lightbend, Inc.
 *
 * Licensed under Apache License 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 *
 * See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 */

package scala

import java.lang.{ StringBuilder => JLSBuilder }
import scala.annotation.tailrec

/** This class provides the basic mechanism to do String Interpolation.
 * String Interpolation allows users
 * to embed variable references directly in *processed* string literals.
 * Here's an example:
 * {{{
 *   val name = "James"
 *   println(s"Hello, \$name")  // Hello, James
 * }}}
 *
 * Any processed string literal is rewritten as an instantiation and
 * method call against this class.   For example:
 * {{{
 *   s"Hello, \$name"
 * }}}
 *
 * is rewritten to be:
 *
 * {{{
 *   StringContext("Hello, ", "").s(name)
 * }}}
 *
 * By default, this class provides the `raw`, `s` and `f` methods as
 * available interpolators.
 *
 * To provide your own string interpolator, create an implicit class
 * which adds a method to `StringContext`.  Here's an example:
 * {{{
 *    implicit class JsonHelper(private val sc: StringContext) extends AnyVal {
 *      def json(args: Any*): JSONObject = ...
 *    }
 *    val x: JSONObject = json"{ a: \$a }"
 * }}}
 *
 *  Here the `JsonHelper` extension class implicitly adds the `json` method to
 *  `StringContext` which can be used for `json` string literals.
 *
 *  @since 2.10.0
 *  @param   parts  The parts that make up the interpolated string,
 *                  without the expressions that get inserted by interpolation.
 */
case class StringContext(parts: String*) {

  import StringContext._

  /** Checks that the length of the given argument `args` is one less than the number
   *  of `parts` supplied to the enclosing `StringContext`.
   *  @param `args` The arguments to be checked.
   *  @throws IllegalArgumentException  if this is not the case.
   */
  def checkLengths(args: Seq[Any]): Unit =
    if (parts.length != args.length + 1)
      throw new IllegalArgumentException("wrong number of arguments ("+ args.length
        +") for interpolated string with "+ parts.length +" parts")


  /** The simple string interpolator.
   *
   *  It inserts its arguments between corresponding parts of the string context.
   *  It also treats standard escape sequences as defined in the Scala specification.
   *  Here's an example of usage:
   *  {{{
   *    val name = "James"
   *    println(s"Hello, \$name")  // Hello, James
   *  }}}
   *  In this example, the expression \$name is replaced with the `toString` of the
   *  variable `name`.
   *  The `s` interpolator can take the `toString` of any arbitrary expression within
   *  a `\${}` block, for example:
   *  {{{
   *    println(s"1 + 1 = \${1 + 1}")
   *  }}}
   *  will print the string `1 + 1 = 2`.
   *
   *  @param `args` The arguments to be inserted into the resulting string.
   *  @throws IllegalArgumentException
   *          if the number of `parts` in the enclosing `StringContext` does not exceed
   *          the number of arguments `arg` by exactly 1.
   *  @throws StringContext.InvalidEscapeException
   *          if a `parts` string contains a backslash (`\`) character
   *          that does not start a valid escape sequence.
   *  @note   The Scala compiler may replace a call to this method with an equivalent, but more efficient,
   *          use of a StringBuilder.
   */
  def s(args: Any*): String = standardInterpolator(treatEscapes, args)

  /** The raw string interpolator.
   *
   *  It inserts its arguments between corresponding parts of the string context.
   *  As opposed to the simple string interpolator `s`, this one does not treat
   *  standard escape sequences as defined in the Scala specification.
   *
   *  For example, the raw processed string `raw"a\nb"` is equal to the scala string `"a\\nb"`.
   *
   *  ''Note:'' Even when using the raw interpolator, Scala will preprocess unicode escapes.
   *  For example:
   *  {{{
   *    scala> raw"\u005cu0023"
   *    res0: String = #
   *  }}}
   *
   *  @param `args` The arguments to be inserted into the resulting string.
   *  @throws IllegalArgumentException
   *          if the number of `parts` in the enclosing `StringContext` does not exceed
   *          the number of arguments `arg` by exactly 1.
   *  @note   The Scala compiler may replace a call to this method with an equivalent, but more efficient,
   *          use of a StringBuilder.
   */
  def raw(args: Any*): String = standardInterpolator(identity, args)

  def standardInterpolator(process: String => String, args: Seq[Any]): String = {
    checkLengths(args)
    val pi = parts.iterator
    val ai = args.iterator
    val bldr = new JLSBuilder(process(pi.next()))
    while (ai.hasNext) {
      bldr append ai.next
      bldr append process(pi.next())
    }
    bldr.toString
  }

  /** The formatted string interpolator.
   *
   *  It inserts its arguments between corresponding parts of the string context.
   *  It also treats standard escape sequences as defined in the Scala specification.
   *  Finally, if an interpolated expression is followed by a `parts` string
   *  that starts with a formatting specifier, the expression is formatted according to that
   *  specifier. All specifiers allowed in Java format strings are handled, and in the same
   *  way they are treated in Java.
   *
   *  For example:
   *  {{{
   *    val height = 1.9d
   *    val name = "James"
   *    println(f"\$name%s is \$height%2.2f meters tall")  // James is 1.90 meters tall
   *  }}}
   *
   *  @param `args` The arguments to be inserted into the resulting string.
   *  @throws IllegalArgumentException
   *          if the number of `parts` in the enclosing `StringContext` does not exceed
   *          the number of arguments `arg` by exactly 1.
   *  @throws StringContext.InvalidEscapeException
   *          if a `parts` string contains a backslash (`\`) character
   *          that does not start a valid escape sequence.
   *
   *  Note: The `f` method works by assembling a format string from all the `parts` strings and using
   *  `java.lang.String.format` to format all arguments with that format string. The format string is
   *  obtained by concatenating all `parts` strings, and performing two transformations:
   *
   *   1. Let a _formatting position_ be a start of any `parts` string except the first one.
   *      If a formatting position does not refer to a `%` character (which is assumed to
   *      start a format specifier), then the string format specifier `%s` is inserted.
   *
   *   2. Any `%` characters not in formatting positions must begin one of the conversions
   *      `%%` (the literal percent) or `%n` (the platform-specific line separator).
   */
  // The implementation is hardwired to `scala.tools.reflect.MacroImplementations.macro_StringInterpolation_f`
  // Using the mechanism implemented in `scala.tools.reflect.FastTrack`
  def f[A >: Any](args: A*): String = macro ???
}

object StringContext {

  /** An exception that is thrown if a string contains a backslash (`\`) character
   *  that does not start a valid escape sequence.
   *  @param  str   The offending string
   *  @param  index   The index of the offending backslash character in `str`.
   */
  class InvalidEscapeException(str: String, @deprecatedName('idx) val index: Int) extends IllegalArgumentException(
    s"""invalid escape ${
      require(index >= 0 && index < str.length)
      val ok = """[\b, \t, \n, \f, \r, \\, \", \']"""
      if (index == str.length - 1) "at terminal" else s"'\\${str(index + 1)}' not one of $ok at"
    } index $index in "$str". Use \\\\ for literal \\."""
  )

  /** Expands standard Scala escape sequences in a string.
   *  Escape sequences are:
   *   control: `\b`, `\t`, `\n`, `\f`, `\r`
   *   escape:  `\\`, `\"`, `\'`
   *   octal:   `\d` `\dd` `\ddd` where `d` is an octal digit between `0` and `7`.
   *
   *  @param  str  A string that may contain escape sequences
   *  @return The string with all escape sequences expanded.
   */
  def treatEscapes(str: String): String = treatEscapes0(str, strict = false)

  /** Treats escapes, but disallows octal escape sequences. */
  def processEscapes(str: String): String = treatEscapes0(str, strict = true)

  private def treatEscapes0(str: String, strict: Boolean): String = {
    val len = str.length
    // replace escapes with given first escape
    def replace(first: Int): String = {
      val b = new JLSBuilder
      // append replacement starting at index `i`, with `next` backslash
      @tailrec def loop(i: Int, next: Int): String = {
        if (next >= 0) {
          //require(str(next) == '\\')
          if (next > i) b.append(str, i, next)
          var idx = next + 1
          if (idx >= len) throw new InvalidEscapeException(str, next)
          val c = str(idx) match {
            case 'b'  => '\b'
            case 't'  => '\t'
            case 'n'  => '\n'
            case 'f'  => '\f'
            case 'r'  => '\r'
            case '"'  => '"'
            case '\'' => '\''
            case '\\' => '\\'
            case o if '0' <= o && o <= '7' =>
              if (strict) throw new InvalidEscapeException(str, next)
              val leadch = str(idx)
              var oct = leadch - '0'
              idx += 1
              if (idx < len && '0' <= str(idx) && str(idx) <= '7') {
                oct = oct * 8 + str(idx) - '0'
                idx += 1
                if (idx < len && leadch <= '3' && '0' <= str(idx) && str(idx) <= '7') {
                  oct = oct * 8 + str(idx) - '0'
                  idx += 1
                }
              }
              idx -= 1   // retreat
              oct.toChar
            case _    => throw new InvalidEscapeException(str, next)
          }
          idx += 1       // advance
          b append c
          loop(idx, str.indexOf('\\', idx))
        } else {
          if (i < len) b.append(str, i, len)
          b.toString
        }
      }
      loop(0, first)
    }
    str indexOf '\\' match {
      case -1 => str
      case  i => replace(i)
    }
  }
}

[0m2021.03.20 18:05:04 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, hello $y)"
}

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  val point1 = new Point(2, 3)
  println(point1.x) // 2
  println(point1) // prints (2, 3)
}

[0m2021.03.20 18:05:15 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  val point1 = new Point(2, 3)
  println(point1.x) // 2
  println(point1) // prints (2, 3)
}

[0m2021.03.20 18:05:40 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  val point1 = new Point(2, 3)
  point1.move(2, 6)
  println(point1.x) // 2
  println(point1) // prints (2, 3)
}

MÃ¤rz 20, 2021 6:05:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 1651
[0m2021.03.20 18:05:54 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)
}

[0m2021.03.20 18:08:19 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100

  def x = _x
  def x_= (newValue: Int): Unit = {
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_= (newValue: Int): Unit = {
    if (newValue < bound) _y = newValue else printWarning
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)
}

[0m2021.03.20 18:09:18 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100

  def x = _x
  def x_=(newValue: Int): Unit = {
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = {
    if (newValue < bound) _y = newValue else printWarning
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 99 // sets the x coordinate
  point1.y = 101 // prints the warning
}

[0m2021.03.20 18:11:08 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = {
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = {
    if (newValue < bound) _y = newValue else printWarning
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 100 // prints the warning
}

[0m2021.03.20 18:11:15 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = {
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = {
    if (newValue < bound) _y = newValue else printWarning
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 99 // prints the warning
}

MÃ¤rz 20, 2021 6:11:33 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2181
MÃ¤rz 20, 2021 6:11:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2319
MÃ¤rz 20, 2021 6:13:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2788
MÃ¤rz 20, 2021 6:13:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2848
MÃ¤rz 20, 2021 6:13:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2849
MÃ¤rz 20, 2021 6:13:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2884
MÃ¤rz 20, 2021 6:14:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 2968
MÃ¤rz 20, 2021 6:17:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3599
MÃ¤rz 20, 2021 6:17:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3630
MÃ¤rz 20, 2021 6:17:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3651
MÃ¤rz 20, 2021 6:17:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3696
MÃ¤rz 20, 2021 6:17:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3697
MÃ¤rz 20, 2021 6:17:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3699
[0m2021.03.20 18:17:52 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def checkBoundaries = { x: _x; y: _y }
  def checkBoundaries_=(justANewVal: Int, workVal: Int): Unit = {
    if (justANewVal.x < bound || justANewVal.y < bound) workVal = justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 99 // prints the warning
}

[0m2021.03.20 18:18:36 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def checkBoundaries = (x: _x, y: _y)
  def checkBoundaries_=(justANewVal: Int, workVal: Int): Unit = {
    if (justANewVal.x < bound || justANewVal.y < bound) workVal = justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 99 // prints the warning
}

MÃ¤rz 20, 2021 6:19:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 3925
[0m2021.03.20 18:19:31 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def checkBoundaries = (x: _x, y: _y)
  def checkBoundaries_=(justANewVal: Int): Unit = {
    if (justANewVal.x < bound || justANewVal.y < bound) justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 99 // prints the warning
}

[0m2021.03.20 18:20:52 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def checkBoundaries = (_x, _y)
  def checkBoundaries_=(justANewVal: Point): Unit = {
    if (justANewVal.x < bound || justANewVal.y < bound) justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 99 // prints the warning
}

[0m2021.03.20 18:21:17 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def checkBoundaries = (_x, _y)
  def checkBoundaries_=(justANewVal: Point): Unit = {
    if (justANewVal.x < bound || justANewVal.y < bound) justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 99 // prints the warning
}

MÃ¤rz 20, 2021 6:21:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4334
[0m2021.03.20 18:22:23 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def checkBoundaries = (x_, y_)
  def checkBoundaries_=(justANewVal: Point): Unit = {
    if (justANewVal.x < bound || justANewVal.y < bound) justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 99 // prints the warning
}

[0m2021.03.20 18:22:34 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def checkBoundaries = (x, y)
  def checkBoundaries_=(justANewVal: Point): Unit = {
    if (justANewVal.x < bound || justANewVal.y < bound) justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 99 // prints the warning
}

[0m2021.03.20 18:23:07 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def checkBoundaries = (x, y)
  def checkBoundaries_=(justANewVal: Point): Unit = {
    if (justANewVal.x < bound || justANewVal.y < bound) justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  // point1.x = 200 // sets the x coordinate
  // point1.y = 99 // prints the warning
  point1(100, 99)
}

[0m2021.03.20 18:23:58 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (x: Int, y: Int) {
  // private var _x = 0
  // private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def checkBoundaries = (x, y)
  def checkBoundaries_=(justANewVal: Point): Unit = {
    if (justANewVal.x < bound || justANewVal.y < bound) justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  // point1.x = 200 // sets the x coordinate
  // point1.y = 99 // prints the warning
  point1(100, 99)
}

[0m2021.03.20 18:24:48 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (x: Int, y: Int) {
  x = 0
  y = 0
  // private var _x = 0
  // private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def checkBoundaries = (x, y)
  def checkBoundaries_=(justANewVal: Point): Unit = {
    if (justANewVal.x < bound || justANewVal.y < bound) justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  // point1.x = 200 // sets the x coordinate
  // point1.y = 99 // prints the warning
  point1(100, 99)
}

MÃ¤rz 20, 2021 6:25:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 4999
[0m2021.03.20 18:25:06 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (x: Int = 0, y: Int = 0) {
  // private var _x = 0
  // private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def checkBoundaries = (x, y)
  def checkBoundaries_=(justANewVal: Point): Unit = {
    if (justANewVal.x < bound || justANewVal.y < bound) justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  // point1.x = 200 // sets the x coordinate
  // point1.y = 99 // prints the warning
  point1(100, 99)
}

MÃ¤rz 20, 2021 6:25:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5061
[0m2021.03.20 18:25:42 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int = 0, var y: Int = 0) {
  // private var _x = 0
  // private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def checkBoundaries = (x, y)
  def checkBoundaries_=(justANewVal: Point): Unit = {
    if (justANewVal.x < bound || justANewVal.y < bound) justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  // point1.x = 200 // sets the x coordinate
  // point1.y = 99 // prints the warning
  point1(100, 99)
}

[0m2021.03.20 18:26:21 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int = 0, var y: Int = 0) {
  private var _x = x
  private var _y = y
  private val bound = 100 // 100 is hard boundary

  def checkBoundaries = (_x, _y)
  def checkBoundaries_=(justANewVal: Point): Unit = {
    if (justANewVal.x < bound || justANewVal.y < bound) justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  // point1.x = 200 // sets the x coordinate
  // point1.y = 99 // prints the warning
  point1(100, 99)
}

[0m2021.03.20 18:26:46 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int = 0, var y: Int = 0) {
  private var _x = x
  private var _y = y
  private val bound = 100 // 100 is hard boundary

  def checkBoundaries = (_x, _y)
  def checkBoundaries_=(justANewVal: Point): Unit = {
    if (justANewVal.x < bound || justANewVal.y < bound) justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 99 // prints the warning
  // point1(100, 99)
}

[0m2021.03.20 18:27:33 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int = 0, var y: Int = 0) {
  private var _x = x
  private var _y = y
  private val bound = 100 // 100 is hard boundary

  def checkBoundaries = (_x, _y)
  def checkBoundaries_=(justANewVal: Point): Unit = {
    if (justANewVal.x < bound || justANewVal.y < bound) checkBoundaries = justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 99 // prints the warning
  // point1(100, 99)
}

MÃ¤rz 20, 2021 6:28:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5467
[0m2021.03.20 18:29:30 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int = 0, var y: Int = 0) {
  private var _x = x
  private var _y = y
  private val bound = 100 // 100 is hard boundary

  def checkBoundaries = (_x, _y)
  def checkBoundaries_=(justANewVal: Point): Unit = {
    if (justANewVal._x < bound || justANewVal._y < bound) checkBoundaries = justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 99 // prints the warning
  // point1(100, 99)
}

MÃ¤rz 20, 2021 6:29:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5711
[0m2021.03.20 18:30:16 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int = 0, var y: Int = 0) {
  private var _x = x
  private var _y = y
  private val bound = 100 // 100 is hard boundary

  def checkBoundaries = (_x, _y)
  def checkBoundaries_=(justANewVal: Point): Unit = {
    println(justANewVal._x)
    println(justANewVal.x)
    if (justANewVal._x < bound || justANewVal._y < bound) checkBoundaries = justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 99 // prints the warning
  // point1(100, 99)
}

MÃ¤rz 20, 2021 6:30:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 5889
[0m2021.03.20 18:30:47 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int = 0, var y: Int = 0) {
  private var _x = x
  private var _y = y
  private val bound = 100 // 100 is hard boundary

  def checkBoundaries = (_x, _y)
  def checkBoundaries_=(justANewVal: Point): Unit = {
    println(justANewVal._x)
    println(justANewVal.x)
    if (justANewVal._x < bound || justANewVal._y < bound) checkBoundaries = justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 99 // prints the warning
  point1.checkBoundaries(200, 99)
  // point1(100, 99)
}

[0m2021.03.20 18:31:31 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int = 0, var y: Int = 0) {
  private var _x = x
  private var _y = y
  private val bound = 100 // 100 is hard boundary

  def checkBoundaries = (_x, _y)
  def checkBoundaries_=(justANewVal: Point): Unit = {
    println(justANewVal._x)
    println(justANewVal.x)
    if (justANewVal._x < bound || justANewVal._y < bound) checkBoundaries = justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 99 // prints the warning
  point1.checkBoundaries({200; 99})
  // point1(100, 99)
}

[0m2021.03.20 18:31:40 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int = 0, var y: Int = 0) {
  private var _x = x
  private var _y = y
  private val bound = 100 // 100 is hard boundary

  def checkBoundaries = (_x, _y)
  def checkBoundaries_=(justANewVal: Point): Unit = {
    println(justANewVal._x)
    println(justANewVal.x)
    if (justANewVal._x < bound || justANewVal._y < bound) checkBoundaries = justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 99 // prints the warning
  point1.checkBoundaries()
  // point1(100, 99)
}

[0m2021.03.20 18:31:46 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int = 0, var y: Int = 0) {
  private var _x = x
  private var _y = y
  private val bound = 100 // 100 is hard boundary

  def checkBoundaries = (_x, _y)
  def checkBoundaries_=(justANewVal: Point): Unit = {
    println(justANewVal._x)
    println(justANewVal.x)
    if (justANewVal._x < bound || justANewVal._y < bound) checkBoundaries = justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 99 // prints the warning
  point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:31:58 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int = 0, var y: Int = 0) {
  private var _x = x
  private var _y = y
  private val bound = 100 // 100 is hard boundary

  def checkBoundaries = (_x, _y)
  def checkBoundaries_=(justANewVal: Point): Unit = {
    println(justANewVal._x)
    println(justANewVal.x)
    if (justANewVal._x < bound || justANewVal._y < bound) checkBoundaries = justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:32:24 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int = 0, var y: Int = 0) {
  private var _x = x
  private var _y = y
  private val bound = 100 // 100 is hard boundary

  def checkBoundaries = (x, y)
  def checkBoundaries_=(justANewVal: Point): Unit = {
    println(justANewVal._x)
    println(justANewVal.x)
    if (justANewVal._x < bound || justANewVal._y < bound) checkBoundaries = justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:32:55 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int = 0, var y: Int = 0) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def checkBoundaries = (x, y)
  def checkBoundaries_=(justANewVal: Point): Unit = {
    // println(justANewVal._x)
    println(justANewVal.x)
    if (justANewVal.x < bound || justANewVal.y < bound) checkBoundaries = justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:33:13 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int = 0, var y: Int = 0) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def checkBoundaries = (x, y)
  def checkBoundaries_=(justANewVal: Point): Unit = {
    println("its going in here")
    // println(justANewVal._x)
    println(justANewVal.x)
    if (justANewVal.x < bound || justANewVal.y < bound) checkBoundaries = justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:33:43 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int = 0, var y: Int = 0) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def Point = (x, y)
  def Point_=(justANewVal: Point): Unit = {
    println("its going in here")
    // println(justANewVal._x)
    println(justANewVal.x)
    if (justANewVal.x < bound || justANewVal.y < bound) checkBoundaries = justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:33:53 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int = 0, var y: Int = 0) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def Point = (x, y)
  def Point_=(justANewVal: Point): Unit = {
    println("its going in here")
    // println(justANewVal._x)
    println(justANewVal.x)
    if (justANewVal.x < bound || justANewVal.y < bound) checkBoundaries = justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 6:33:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6464
MÃ¤rz 20, 2021 6:34:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6502
MÃ¤rz 20, 2021 6:34:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6547
MÃ¤rz 20, 2021 6:34:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6549
[0m2021.03.20 18:34:17 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int = 0, var y: Int = 0) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def Point = (x, y)
  def Point_=(justANewVal: Point): Unit = {
    println("its going in here")
    // println(justANewVal._x)
    println(justANewVal.x)
    if (justANewVal.x < bound || justANewVal.y < bound) Point = justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 6:34:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6627
MÃ¤rz 20, 2021 6:34:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6628
MÃ¤rz 20, 2021 6:34:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6629
MÃ¤rz 20, 2021 6:34:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6693
MÃ¤rz 20, 2021 6:34:52 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: offset 2774, count -1, length 2833
MÃ¤rz 20, 2021 6:34:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 6764
[0m2021.03.20 18:34:57 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int = 0, var y: Int = 0) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def Point = (x, y)
  def Point_=(justANewVal: Point): Unit = {
    println("its going in here")
    // println(justANewVal._x)
    println(justANewVal.x)
    if (justANewVal.x < bound || justANewVal.y < bound) Point = justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  println(point1)
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:35:27 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int = 0, var y: Int = 0) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def Point = (x, y)
  def Point_=(justANewVal: Point): Unit = {
    println("its going in here")
    // println(justANewVal._x)
    println(justANewVal.x)
    if (justANewVal.x < bound || justANewVal.y < bound) Point = justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  point1.Point
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:35:39 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int = 0, var y: Int = 0) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def Point = (x, y)
  def Point_=(justANewVal: Point): Unit = {
    println("its going in here")
    // println(justANewVal._x)
    println(justANewVal.x)
    if (justANewVal.x < bound || justANewVal.y < bound) Point = justANewVal else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  point1.Point(200, 200)
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:36:30 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int = 0, var y: Int = 0) {
  private var _x = x
  private var _y = y
  private val bound = 100 // 100 is hard boundary

  /*def Point = (x, y)
  def Point_=(justANewVal: Point): Unit = {
    println("its going in here")
    // println(justANewVal._x)
    println(justANewVal.x)
    if (justANewVal.x < bound || justANewVal.y < bound) Point = justANewVal else printWarning
  }*/

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 6:36:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7015
[0m2021.03.20 18:36:46 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = x
  private var _y = y
  private val bound = 100 // 100 is hard boundary

  /*def Point = (x, y)
  def Point_=(justANewVal: Point): Unit = {
    println("its going in here")
    // println(justANewVal._x)
    println(justANewVal.x)
    if (justANewVal.x < bound || justANewVal.y < bound) Point = justANewVal else printWarning
  }*/

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 6:36:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 7075
[0m2021.03.20 18:37:16 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  /*def Point = (x, y)
  def Point_=(justANewVal: Point): Unit = {
    println("its going in here")
    // println(justANewVal._x)
    println(justANewVal.x)
    if (justANewVal.x < bound || justANewVal.y < bound) Point = justANewVal else printWarning
  }*/

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    if (newValue < bound) _x = newValue else printWarning
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    if (newValue < bound) _y = newValue else printWarning
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:39:09 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates = (_x, _y)
  def setCoordinates_=(justANewVal: Point): Unit = {
    println("its going in here")
    // println(justANewVal._x)
    println(justANewVal.x)
    if (justANewVal.x < bound || justANewVal.y < bound) Point = justANewVal else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(x, y)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(x, y)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:39:59 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates = (_x, _y)
  def setCoordinates_=(x: Int, y: Int): Unit = {
    println("its going in here")
    // println(justANewVal._x)
    println(justANewVal.x)
    if (justANewVal.x < bound || justANewVal.y < bound) Point = justANewVal else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(x, y)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(x, y)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:40:18 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates = (_x, _y)
  def setCoordinates_=(x: Int, y: Int): Unit = {
    println("its going in here")
    // println(justANewVal._x)
    println(justANewVal.x)
    if (justANewVal.x < bound || justANewVal.y < bound) setCoordinates = justANewVal else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(x, y)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(x, y)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:40:50 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates = (_x, _y)
  def setCoordinates_=(x: Int, y: Int): Unit = {
    println("its going in here")
    // println(justANewVal._x)
    println(x)
    if (x < bound || y < bound) setCoordinates = x else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(x, y)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(x, y)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:41:14 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates = (_x, _y)
  def setCoordinates_=(x: Int, y: Int): Unit = {
    println("its going in here")
    // println(justANewVal._x)
    println(x)
    if (x < bound || y < bound) setCoordinates = (x, y) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(x, y)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(x, y)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:41:48 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates = (_x, _y)
  def setCoordinates_=(x: Int, y: Int): Unit = {
    println("its going in here")
    // println(justANewVal._x)
    println(_x)
    if (_x < bound || _y < bound) setCoordinates = (_x, _y) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(x, y)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(x, y)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:42:01 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates = (_x, _y)
  def setCoordinates_=(x: Int, y: Int): Unit = {
    println("its going in here")
    // println(justANewVal._x)
    println(_x)
    if (_x < bound || _y < bound) setCoordinates(_x, _y) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(x, y)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(x, y)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:44:08 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates = (_x, _y)
  def setCoordinates_=(val1: Int, val2: Int): Unit = {
    println("its going in here")
    // println(justANewVal._x)
    println(val1)
    // if (_x < bound || _y < bound) setCoordinates(_x, _y) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(x, y)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(x, y)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:44:27 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates = (_x, _y)
  def setCoordinates_=(val1: Int, val2: Int): Unit = {
    println("its going in here")
    // println(justANewVal._x)
    println(val1)
    // if (_x < bound || _y < bound) setCoordinates(_x, _y) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates()
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates()
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:44:39 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates = (_x, _y)
  def setCoordinates_=(val1: Int, val2: Int): Unit = {
    println("its going in here")
    // println(justANewVal._x)
    println(val1)
    // if (_x < bound || _y < bound) setCoordinates(_x, _y) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:46:11 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates = (_x, _y)
  def setCoordinates_=(val1: Int, val2: Int): Unit = {
    println("its going in here")
    // println(justANewVal._x)
    println(val1)
    printWarning
    // if (_x < bound || _y < bound) setCoordinates(_x, _y) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 6:46:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8740
MÃ¤rz 20, 2021 6:47:06 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 8826
[0m2021.03.20 18:47:17 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates = (_x, _y)
  def setCoordinates_=(val1: Int, val2: Int): Unit = {
    println("its going in here")
    // println(justANewVal._x)
    // println(val1)
    // printWarning
    // if (_x < bound || _y < bound) setCoordinates(_x, _y) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:47:41 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  // def setCoordinates = (_x, _y)
  def setCoordinates_=(val1: Int, val2: Int): Unit = {
    println("its going in here")
    // println(justANewVal._x)
    // println(val1)
    // printWarning
    // if (_x < bound || _y < bound) setCoordinates(_x, _y) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:47:56 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  // def setCoordinates = (_x, _y)
  def setCoordinates_=(val1: Int = 0, val2: Int = 0): Unit = {
    println("its going in here")
    // println(justANewVal._x)
    // println(val1)
    // printWarning
    // if (_x < bound || _y < bound) setCoordinates(_x, _y) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 6:48:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9113
[0m2021.03.20 18:48:39 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  // def setCoordinates = (_x, _y)
  def setCoordinates=(val1: Int, val2: Int) {
    println("its going in here")
    // println(justANewVal._x)
    // println(val1)
    // printWarning
    // if (_x < bound || _y < bound) setCoordinates(_x, _y) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:49:07 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
[0m2021.03.20 18:49:26 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  // def setCoordinates = (_x, _y)
  def setCoordinates(val1: Int, val2: Int) {
    println("its going in here")
    // println(justANewVal._x)
    // println(val1)
    // printWarning
    // if (_x < bound || _y < bound) setCoordinates(_x, _y) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 6:49:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9301
MÃ¤rz 20, 2021 6:49:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9302
[0m2021.03.20 18:49:58 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  // def setCoordinates = (_x, _y)
  def setCoordinates(val1: Int, val2: Int) {
    // println("its going in here")
    // println(justANewVal._x)
    // println(val1)
    // printWarning
    if (val1 < bound || val2 < bound) setCoordinates(_x, _y) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 6:50:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9514
[0m2021.03.20 18:50:35 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  // def setCoordinates = (_x, _y)
  def setCoordinates(val1: Int, val2: Int) {
    // println("its going in here")
    // println(justANewVal._x)
    // println(val1)
    // printWarning
    if (val1 < bound || val2 < bound) println("everything went fine") else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 6:50:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9553
MÃ¤rz 20, 2021 6:50:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9554
[0m2021.03.20 18:51:19 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  // def setCoordinates = (_x, _y)
  def setCoordinates(val1: Int, val2: Int) {
    // println("its going in here")
    // println(justANewVal._x)
    // println(val1)
    // printWarning
    if (val1 < bound || val2 < bound) println("everything went fine") else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    println(newValue)
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:52:30 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    println(val1 < bound)
    if (val1 < bound || val2 < bound) println("everything went fine") else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 6:52:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 9977
[0m2021.03.20 18:53:38 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    println(val1 < bound)
    if (val1 < bound || val2 < bound) printWarning else println("val1: ", val1, " val2: ", val2)
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  println("""|Hello, Austria!""".stripMargin)
  println(200 + 1000000)

  def name: String = System.getProperty("""|user.name""".stripMargin)
  println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  val greeter = new DefaultGreeter()
  greeter.greet("Scala developer") // Hello, Scala developer!

  val customGreeter = new CustomizableGreeter("How are you, ", "?")
  customGreeter.greet("Scala developer") // How are you, Scala developer?

  val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:54:42 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    println(val1 < bound)
    if (val1 < bound || val2 < bound) printWarning else println("val1: ", val1, " val2: ", val2)
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 6:55:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 10479
[0m2021.03.20 18:55:31 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    println(val1 < bound)
    if (val1 < bound || val2 < bound) printWarning else println("val1: ", val1, " val2: ", val2)
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 99 // sets the x coordinate
  point1.y = 88 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:55:57 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    println(val1 < bound)
    if (val1 < bound || val2 < bound) println("val1: ", val1, " val2: ", val2) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 99 // sets the x coordinate
  point1.y = 88 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:56:37 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    println(val1 < bound)
    if (val1 < bound || val2 < bound) println("val1: " val1, " val2: " val2) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 99 // sets the x coordinate
  point1.y = 88 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:56:57 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    println(val1 < bound)
    if (val1 < bound || val2 < bound) println("val1: ", val1, " val2: ", val2) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 99 // sets the x coordinate
  point1.y = 88 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:57:17 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    println(val1 < bound)
    if (val1 < bound || val2 < bound) println("val1: ", val1, " val2: ", val2) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:58:19 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    println(val1 < bound)
    if (val1 < bound && val2 < bound) println("val1: ", val1, " val2: ", val2) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:58:32 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) println("val1: ", val1, " val2: ", val2) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 200 // sets the x coordinate
  point1.y = 200 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:58:43 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) println("val1: ", val1, " val2: ", val2) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 18:59:47 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s", val1, val2) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:00:06 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\r\n", val1, val2) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:00:19 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s \r\n", val1, val2) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:00:27 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s", val1, val2) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:01:16 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) println("val1: %s, val2: %s", val1, val2) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:01:26 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s", val1, val2) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:01:57 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }

  def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:05:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 11928
[0m2021.03.20 19:05:57 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (val x: Int, val y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def Point() {
    setCoordinates(x, y)
  }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(50, 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:06:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12087
MÃ¤rz 20, 2021 7:06:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 12096
[0m2021.03.20 19:06:48 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (val x: Int, val y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def Point(newX: Int, newY: Int) {
    setCoordinates(newX, newY)
  }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(50, 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:07:09 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (val x: Int, val y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def Point_(newX: Int, newY: Int) {
    setCoordinates(newX, newY)
  }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(50, 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:07:16 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (val x: Int, val y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def Point(newX: Int, newY: Int) {
    setCoordinates(newX, newY)
  }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(50, 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:08:44 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def setCooridnates = { _x: x; _y: y }
  def setCoordinates_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(50, 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:09:12 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def setCooridnates = ( x, y )
  def setCoordinates_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(50, 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:10:13 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def setCooridnates = ( x, y )
  def setCoordinates_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:10:50 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:10:50 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:10:52 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:10:52 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:10:53 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:10:54 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:10:54 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:10:54 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:10:55 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:10:56 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:10:57 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:10:59 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:10:59 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:10:59 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:10:59 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:11:00 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:11:00 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:11:00 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:11:00 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:11:00 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:11:02 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:11:03 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:11:03 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:11:04 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:11:04 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:11:04 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:11:04 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:11:05 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:11:06 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:11:07 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:11:07 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:11:07 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:11:07 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:11:07 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:11:08 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:11:08 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

class Point (var x: Int, var y: Int) {
  // private var _x = x
  // private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:11:09 PM scala.meta.internal.pc.CompilerAccess handleError
SEVERE: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
java.lang.RuntimeException: ambiguous mend file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@145..145  file%3A%2F%2F%2Fhome%2Fnevermind%2Fscalademo%2Fhello-world-template%2Fsrc%2Fmain%2Fscala%2FMain.scala@144..145 x
	at scala.sys.package$.error(package.scala:30)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.indexName(TextDocumentOps.scala:96)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:190)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.transversers.Traverser.apply(Traverser.scala:4)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument$traverser$1$.apply(TextDocumentOps.scala:197)
	at scala.meta.internal.semanticdb.scalac.TextDocumentOps$XtensionCompilationUnitDocument.toTextDocument(TextDocumentOps.scala:201)
	at scala.meta.internal.pc.SemanticdbTextDocumentProvider.textDocument(SemanticdbTextDocumentProvider.scala:52)

[0m2021.03.20 19:11:10 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int, var y: Int) {
  private var _x = x
  private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def x_(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:11:42 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int, var y: Int) {
  private var _x = x
  private var _y = y
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:13:12 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int, var y: Int) {
  private var _x = x
  private var _y = y
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  def Main() {
    setCoordinates(x, y)
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:13:21 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int, var y: Int) {
  private var _x = x
  private var _y = y
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  def main() {
    setCoordinates(x, y)
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:14:17 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int, var y: Int) {
  private var _x = x
  private var _y = y
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  public static void Point() {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:14:25 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int, var y: Int) {
  private var _x = x
  private var _y = y
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  public static Point() {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:14:54 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int, var y: Int) {
  private var _x = x
  private var _y = y
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  public static Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:15:16 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int, var y: Int) {
  private var _x = x
  private var _y = y
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:15:26 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int, var y: Int) {
  private var _x = x
  private var _y = y
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  def Point_(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:15:53 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int, var y: Int) {
  private var _x = x
  private var _y = y
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  def main(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:16:28 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int, var y: Int) {
  /*private var _x = x
  private var _y = y*/
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  def main(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:16:50 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point (var x: Int, var y: Int) {
  /*private var _x = x
  private var _y = y*/
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  public static void main(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:17:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13735
MÃ¤rz 20, 2021 7:17:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13792
MÃ¤rz 20, 2021 7:17:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13853
MÃ¤rz 20, 2021 7:17:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 13926
[0m2021.03.20 19:18:01 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  /*private var _x = x
  private var _y = y*/
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  public static void Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(x = 50, y = 200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:18:20 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  /*private var _x = x
  private var _y = y*/
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  public static void Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(50,200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:19:08 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  /*private var _x = x
  private var _y = y*/
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point(50,200) // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:19:31 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14175
[0m2021.03.20 19:19:34 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  /*private var _x = x
  private var _y = y*/
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point() // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:19:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 14208
[0m2021.03.20 19:19:47 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = x
  private var _y = y
  private val bound = 100 // 100 is hard boundary

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point() // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:20:11 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = x
  private var _y = y
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point() // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:20:25 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point() // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:21:24 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_ = setCoordinates(x, y)
  def y_ = setCoordinates(x, y)

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point() // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:21:44 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_ = setCoordinates_(x, y)
  def y_ = setCoordinates_(x, y)

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point() // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:22:32 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: offset 164, count -16, length 2964
[0m2021.03.20 19:25:59 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point() // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:26:21 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x_, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point() // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:26:27 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(valX, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point() // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:26:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 15562
[0m2021.03.20 19:26:45 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  // def x = _x
  // def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point() // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:26:53 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point() // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

[0m2021.03.20 19:28:04 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
[0m2021.03.20 19:31:01 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
object MyDummyObject {
  def constructor(someVal: Int) {
    return someVal + 200
  }
}

class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point() // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)
}

MÃ¤rz 20, 2021 7:31:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 16063
[0m2021.03.20 19:31:32 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
object MyDummyObject {
  def constructor(someVal: Int) {
    return someVal + 200
  }
}

class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2) else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 = new Point() // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  var dummyObject = MyDummyObject(200)
  println(dummyObject)
}

[0m2021.03.20 19:33:53 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
object MyDummyObject {
  def constructor(someVal: Int) {
    class Impl(var current: Int) {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    return new Impl(startingValue)
  }
}

class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 =
    new Point() // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  var dummyObject = MyDummyObject(200)
  println(dummyObject)
}

[0m2021.03.20 19:34:08 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
object MyDummyObject {
  def constructor(someVal: Int) {
    class Impl(var current: Int) {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    return new Impl(someVal)
  }
}

class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 =
    new Point() // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  var dummyObject = MyDummyObject(200)
  println(dummyObject)
}

MÃ¤rz 20, 2021 7:35:00 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: offset 212, count -1, length 3317
MÃ¤rz 20, 2021 7:35:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 16541
MÃ¤rz 20, 2021 7:35:31 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: Cannot invoke "scala.reflect.internal.Types$Type.decls()" because the return value of "scala.reflect.internal.Trees$Tree.tpe()" is null
[0m2021.03.20 19:35:50 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
object MyDummyObject {
  def constructor(someVal: Int) {
    class Impl(var current: Int) {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    println(myImpl)
    return new Impl(someVal)
  }
}

class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 =
    new Point() // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  var dummyObject = MyDummyObject(200)
  println(dummyObject)
}

[0m2021.03.20 19:36:03 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
object MyDummyObject {
  def constructor(someVal: Int) {
    class Impl(var current: Int) {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    println(myImpl)
    return null// new Impl(someVal)
  }
}

class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 =
    new Point() // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  var dummyObject = MyDummyObject(200)
  println(dummyObject)
}

MÃ¤rz 20, 2021 7:36:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 16788
[0m2021.03.20 19:36:21 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
object MyDummyObject {
  def constructor(someVal: Int) {
    class Impl(var current: Int) {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    println(myImpl)
    // return new Impl(someVal)
  }
}

class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 =
    new Point() // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  var dummyObject = MyDummyObject(200)
  println(dummyObject)
}

MÃ¤rz 20, 2021 7:37:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 17059
MÃ¤rz 20, 2021 7:37:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 17060
[0m2021.03.20 19:37:46 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
object MyDummyObject {
  def constructor(someVal: Int) {
    println(someVal)
    class Impl(var current: Int) {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    println(myImpl)
    // return new Impl(someVal)
  }
}

class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 =
    new Point() // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  var dummyObject = MyDummyObject(200)
  println(dummyObject)
}

[0m2021.03.20 19:37:58 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
object MyDummyObject {
  def construct(someVal: Int) {
    println(someVal)
    class Impl(var current: Int) {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    println(myImpl)
    // return new Impl(someVal)
  }
}

class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  val point1 =
    new Point() // class call with default constructor values and without an ()
  point1.x = 50 // sets the x coordinate
  point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  var dummyObject = MyDummyObject(200)
  println(dummyObject)
}

[0m2021.03.20 19:38:23 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
object MyDummyObject {
  def construct(someVal: Int) {
    println(someVal)
    class Impl(var current: Int) {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    println(myImpl)
    // return new Impl(someVal)
  }
}

class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  var dummyObject = MyDummyObject.construct(200)
  println(dummyObject)
}

[0m2021.03.20 19:38:42 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
object MyDummyObject {
  def construct(someVal: Int) {
    class Impl(var current: Int) {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    println(myImpl)
    return new Impl(someVal)
  }
}

class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  var dummyObject = MyDummyObject.construct(200)
  println(dummyObject)
}

[0m2021.03.20 19:39:11 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
object MyDummyObject {
  def construct(someVal: Int) {
    class Impl(var current: Int) {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    println(myImpl)
    return myImpl
  }
}

class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  var dummyObject = MyDummyObject.construct(200)
  println(dummyObject)
}

MÃ¤rz 20, 2021 7:40:00 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: Cannot invoke "scala.reflect.internal.Types$Type.decls()" because the return value of "scala.reflect.internal.Trees$Tree.tpe()" is null
[0m2021.03.20 19:40:57 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    println(myImpl)
    return myImpl
  }
}

class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  var dummyObject = MyDummyObject.construct(200)
  println(dummyObject)
}

[0m2021.03.20 19:41:15 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  var dummyObject = MyDummyObject.construct(200)
  println(dummyObject)
}

[0m2021.03.20 19:41:41 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  var dummyObject = MyDummyObject.construct(200)
  println(dummyObject.operation(1000))
}

[0m2021.03.20 19:43:07 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
/*trait Interface {
  def operation(adjust: Int) : Int;
}*/

object MyDummyObject {
  def construct(someVal: Int)/*: Interface*/ = {
    class Impl(var current: Int)/* extends Interface*/ {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  var dummyObject = MyDummyObject.construct(200)
  println(dummyObject.operation(1000))
}

[0m2021.03.20 19:43:33 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
/*trait Interface {
  def operation(adjust: Int) : Int;
}*/

object MyDummyObject {
  def construct(someVal: Int)/*: Interface*/ = {
    class Impl(var current: Int)/* extends Interface*/ {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl as Impl
  }
}

class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  var dummyObject = MyDummyObject.construct(200)
  println(dummyObject.operation(1000))
}

[0m2021.03.20 19:43:44 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
/*trait Interface {
  def operation(adjust: Int) : Int;
}*/

object MyDummyObject {
  def construct(someVal: Int)/*: Interface*/ = {
    class Impl(var current: Int)/* extends Interface*/ {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl: Impl = new Impl(someVal)
    return myImpl
  }
}

class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  var dummyObject = MyDummyObject.construct(200)
  println(dummyObject.operation(1000))
}

[0m2021.03.20 19:44:19 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
/*trait Interface {
  def operation(adjust: Int) : Int;
}*/

object MyDummyObject {
  def construct(someVal: Int): Impl /*: Interface*/ = {
    class Impl(var current: Int) extends Impl /* extends Interface*/ {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl: Impl = new Impl(someVal)
    return myImpl
  }
}

class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  var dummyObject = MyDummyObject.construct(200)
  println(dummyObject.operation(1000))
}

MÃ¤rz 20, 2021 7:44:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 17989
[0m2021.03.20 19:44:27 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
/*trait Interface {
  def operation(adjust: Int) : Int;
}*/

object MyDummyObject {
  def construct(someVal: Int): Impl /*: Interface*/ = {
    class Impl(var current: Int)/* extends Interface*/ {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl: Impl = new Impl(someVal)
    return myImpl
  }
}

class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  var dummyObject = MyDummyObject.construct(200)
  println(dummyObject.operation(1000))
}

[0m2021.03.20 19:45:00 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

object MyDummyObject {
  def construct(someVal: Int)/*: Interface*/ = {
    class Impl(var current: Int)/* extends Interface*/ {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl: Impl = new Impl(someVal)
    return myImpl
  }
}

class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  var dummyObject = MyDummyObject.construct(200)
  println(dummyObject.operation(1000))
}

[0m2021.03.20 19:45:02 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
[0m2021.03.20 19:45:02 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
[0m2021.03.20 19:45:02 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
[0m2021.03.20 19:45:03 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
[0m2021.03.20 19:45:03 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
[0m2021.03.20 19:45:04 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
[0m2021.03.20 19:45:21 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
/*trait Interface {
  def operation(adjust: Int) : Int;
}*/

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int)/* extends Interface*/ {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl: Impl = new Impl(someVal)
    return myImpl
  }
}

class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  var dummyObject = MyDummyObject.construct(200)
  println(dummyObject.operation(1000))
}

MÃ¤rz 20, 2021 7:45:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 18214
[0m2021.03.20 19:45:41 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
/*trait Interface {
  def operation(adjust: Int) : Int;
}*/

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  var dummyObject = MyDummyObject.construct(200)
  println(dummyObject.operation(1000))
}

[0m2021.03.20 19:45:53 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  var dummyObject = MyDummyObject.construct(200)
  println(dummyObject.operation(1000))
}

MÃ¤rz 20, 2021 7:47:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 18680
MÃ¤rz 20, 2021 7:49:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 19182
MÃ¤rz 20, 2021 7:49:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 19237
MÃ¤rz 20, 2021 7:52:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 19846
MÃ¤rz 20, 2021 7:52:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 19933
[0m2021.03.20 19:52:56 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(x: Int, y: Int): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    def runmagic() {
      printf("x: %s, y: %s \n", x, y)
    }
  }
}

class Point extends PointMagic {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200)
  println(dummyPoint.runmagic())
}

[0m2021.03.20 19:53:11 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    def runmagic() {
      printf("x: %s, y: %s \n", x, y)
    }
  }
}

class Point extends PointMagic {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200)
  println(dummyPoint.runmagic())
}

[0m2021.03.20 19:53:50 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    def runmagic() {
      return ("x: %s, y: %s \n", x, y)
    }
  }
}

class Point extends PointMagic {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200)
  println(dummyPoint.runmagic())
}

[0m2021.03.20 19:54:02 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    def runmagic() {
      return "its a string"
    }
  }
}

class Point extends PointMagic {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200)
  println(dummyPoint.runmagic())
}

[0m2021.03.20 19:54:23 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    def runmagic() = {
      return "its a string"
    }
  }
}

class Point extends PointMagic {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200)
  println(dummyPoint.runmagic())
}

[0m2021.03.20 19:54:33 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    def runmagic(): String = {
      return "its a string"
    }
  }
}

class Point extends PointMagic {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200)
  println(dummyPoint.runmagic())
}

MÃ¤rz 20, 2021 7:54:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 20297
MÃ¤rz 20, 2021 7:55:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 20388
[0m2021.03.20 19:55:34 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    def runmagic() {
      println("its a string")
    }
  }
}

class Point extends PointMagic {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200)
  println(dummyPoint.runmagic())
}

MÃ¤rz 20, 2021 7:55:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 20554
MÃ¤rz 20, 2021 7:56:06 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: Cannot invoke "scala.reflect.internal.Types$Type.decls()" because the return value of "scala.reflect.internal.Trees$Tree.tpe()" is null
MÃ¤rz 20, 2021 7:56:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 20616
[0m2021.03.20 19:56:18 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    def runmagic(): String = {
      println("its a string")
      return "yet another string"
    }
  }
}

class Point extends PointMagic {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200)
  println(dummyPoint.runmagic())
}

MÃ¤rz 20, 2021 7:57:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 20795
[0m2021.03.20 19:57:14 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): String = {
    def runmagic(): String = {
      println("its a string")
      return "yet another string"
    }
    return "yet another another string"
  }
}

class Point extends PointMagic {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200)
  println(dummyPoint.runmagic())
}

[0m2021.03.20 19:57:25 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    def runmagic(): String = {
      println("its a string")
      return "yet another string"
    }
    return "yet another another string"
  }
}

class Point extends PointMagic {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200)
  println(dummyPoint.runmagic())
}

[0m2021.03.20 19:57:48 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    def runmagic(): String = {
      println("its a string")
      return "yet another string"
    }
    return new Point(x, y)
  }
}

class Point extends PointMagic {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200)
  println(dummyPoint.runmagic())
}

[0m2021.03.20 19:58:32 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    def runmagic() = {
      println("its a string")
      return "yet another string"
    }
    return new Point
  }
}

class Point extends PointMagic {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200)
  println(dummyPoint.runmagic())
}

[0m2021.03.20 19:58:45 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    def runmagic(): String = {
      println("its a string")
      return "yet another string"
    }
    return new Point
  }
}

class Point extends PointMagic {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200)
  println(dummyPoint.runmagic())
}

[0m2021.03.20 19:59:01 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    def runmagic(): String = {
      println("its a string")
      return "yet another string"
    }
    return new Point
  }
}

abstract class Point extends PointMagic {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200)
  println(dummyPoint.runmagic())
}

[0m2021.03.20 19:59:12 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    def runmagic(): String = {
      println("its a string")
      return "yet another string"
    }
    return Point
  }
}

abstract class Point extends PointMagic {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200)
  println(dummyPoint.runmagic())
}

[0m2021.03.20 20:00:33 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    return new Point
  }
}

class Point extends PointMagic {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200)
  println(dummyPoint.runmagic())
}

[0m2021.03.20 20:01:13 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    return new Point
  }
}

class Point extends PointMagic {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  def runmagic(): String = {
    return "just a string"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200)
  println(dummyPoint.runmagic())
}

MÃ¤rz 20, 2021 8:01:32 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 21751
MÃ¤rz 20, 2021 8:02:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 21935
[0m2021.03.20 20:02:32 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    return new Point(x, y)
  }
}

class Point extends PointMagic {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  def runmagic(): String = {
    return "just a string"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

[0m2021.03.20 20:02:58 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    return new Point
  }
}

class Point extends PointMagic {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  def runmagic(): String = {
    return x
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

[0m2021.03.20 20:03:27 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    return new Point
  }
}

class Point extends PointMagic {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  def runmagic(): String = {
    var newX: String = x
    return newX
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

[0m2021.03.20 20:03:57 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    return new Point
  }
}

class Point extends PointMagic {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  def runmagic(): String = {
    var newX: String = x.toString
    return newX
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

MÃ¤rz 20, 2021 8:04:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 22387
[0m2021.03.20 20:04:55 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    var myPoint = new Point
    myPoint.x = x
    myPoint.y = y
    return new Point
  }
}

class Point extends PointMagic {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  def runmagic(): String = {
    var newX: String = x.toString
    return newX
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

MÃ¤rz 20, 2021 8:06:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 22746
[0m2021.03.20 20:06:35 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    var myPoint = new Point
    myPoint.x = x
    myPoint.y = y
    return new Point
  }
}

class Point extends PointMagic {
  private var _x = 0
  private var _y = 0
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  def runmagic(): String = {
    var newX: String = x.toString
    return newX
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

MÃ¤rz 20, 2021 8:06:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 22820
[0m2021.03.20 20:07:01 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    var myPoint = new Point
    myPoint.x = x
    myPoint.y = y
    return new Point
  }
}

class Point extends PointMagic {
  private var _x = x_
  private var _y = y_
  private val bound = 100 // 100 is hard boundary

  def x = _x
  def y = _y

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  def runmagic(): String = {
    var newX: String = x.toString
    return newX
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

[0m2021.03.20 20:07:40 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    var myPoint = new Point
    myPoint.x = x
    myPoint.y = y
    return new Point
  }
}

class Point extends PointMagic {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  def x = x_
  def y = y_

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  def runmagic(): String = {
    var newX: String = x.toString
    return newX
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

MÃ¤rz 20, 2021 8:08:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 23157
[0m2021.03.20 20:08:25 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    var myPoint = new Point
    myPoint.x = x
    myPoint.y = y
    return new Point
  }
}

class Point (var x: Int, var y: Int) extends PointMagic {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  def runmagic(): String = {
    var newX: String = x.toString
    return newX
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

MÃ¤rz 20, 2021 8:08:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 23167
[0m2021.03.20 20:08:44 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    var myPoint = new Point(x, y)
    return new Point
  }
}

class Point (var x: Int, var y: Int) extends PointMagic {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  def runmagic(): String = {
    var newX: String = x.toString
    return newX
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

[0m2021.03.20 20:09:16 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point (var x: Int, var y: Int) extends PointMagic {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  def runmagic(): String = {
    var newX: String = x.toString
    return newX
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

[0m2021.03.20 20:10:03 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point (var x: Int, var y: Int) extends PointMagic {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  def runmagic(): String = {
    // var newX: String = x.toString
    return ("x: %s, y: %s", x, y)
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

[0m2021.03.20 20:11:21 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point (var x: Int, var y: Int) extends PointMagic {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  def runmagic(): String = {
    // var newX: String = x.toString
    return s"x: $s, y: $s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

[0m2021.03.20 20:12:06 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point (var x: Int, var y: Int) extends PointMagic {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  def runmagic(): String = {
    // var newX: String = x.toString
    return s"x: $x, y: $y"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

[0m2021.03.20 20:12:17 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point (var x: Int, var y: Int) extends PointMagic {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x, y: $y"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

MÃ¤rz 20, 2021 8:12:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 23519
[0m2021.03.20 20:14:23 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point (var x: Int, var y: Int) extends PointMagic {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

[0m2021.03.20 20:18:46 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point (var x: Int, var y: Int) extends PointMagic {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  def runmagic() = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

[0m2021.03.20 20:19:01 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point (var x: Int, var y: Int) extends PointMagic {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

[0m2021.03.20 20:19:11 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic[Point] {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point (var x: Int, var y: Int) extends PointMagic {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

[0m2021.03.20 20:19:27 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point (var x: Int, var y: Int) extends PointMagic {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

[0m2021.03.20 20:20:26 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic {
  def runmagic(): String;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point (var x: Int, var y: Int) extends PointMagic {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

[0m2021.03.20 20:21:41 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic[A] {
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point (var x: Int, var y: Int) extends PointMagic {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

something's wrong: no file:///home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala in PointMagic[<error>]RangePosition(file:///home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala, 572, 572, 592)
something's wrong: no file:///home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala in PointMagic[<error>]RangePosition(file:///home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala, 572, 572, 1617)
[0m2021.03.20 20:21:59 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic[A] {
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point (var x: Int, var y: Int) extends PointMagic[A] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): A = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

[0m2021.03.20 20:22:11 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic[A] {
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point (var x: Int, var y: Int) extends PointMagic[String] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

[0m2021.03.20 20:23:07 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic[A] {
  def x: Int;
  def y: Int;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point (var x: Int, var y: Int) extends PointMagic[String] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

MÃ¤rz 20, 2021 8:23:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 24386
MÃ¤rz 20, 2021 8:23:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 24387
something's wrong: no file:///home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala in PointMagic[String,<error>]RangePosition(file:///home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala, 604, 604, 631)
something's wrong: no file:///home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala in PointMagic[String,<error>]RangePosition(file:///home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala, 604, 604, 632)
[0m2021.03.20 20:23:54 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point (var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

[0m2021.03.20 20:25:15 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point (var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

[0m2021.03.20 20:26:36 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

trait Pet {
  val name: String
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int) : Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point (var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  println(dummyPoint.runmagic()) // return something... lets check the val content
}

[0m2021.03.20 20:27:07 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

trait Pet {
  val name: String
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  val dog = new Dog("Harry")
  val cat = new Cat("Sally")

  val animals = ArrayBuffer.empty[Pet]
  animals.append(dog)
  animals.append(cat)
  animals.foreach(pet => println(pet.name)) // Prints Harry Sally
}

[0m2021.03.20 20:28:04 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

trait Pet {
  val name: String
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  val dog = new Dog("Harry")
  val cat = new Cat("Sally")

  // create an empty array of type Pet
  val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  animals.append(dog)
  animals.append(cat)

  animals.foreach(pet => println(pet.name)) // Prints Harry Sally
}

[0m2021.03.20 20:28:34 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

trait Pet {
  val name: String
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  val dog = new Dog("Harry")
  val cat = new Cat("Sally")

  // create an empty array of type Pet
  val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  animals.append(dog)
  animals.append(cat)

  animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)
}

[0m2021.03.20 20:29:09 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  val dog = new Dog("Harry")
  val cat = new Cat("Sally")

  // create an empty array of type Pet
  val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  animals.append(dog)
  animals.append(cat)

  animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)
}

MÃ¤rz 20, 2021 8:33:21 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: offset 4714, count -1, length 4869
[0m2021.03.20 20:33:52 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition

  // start of val planets operation
  planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ =>
  }
}

[0m2021.03.20 20:34:39 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition

  // start of val planets operation
  planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet")
  }
}

MÃ¤rz 20, 2021 8:34:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 25479
[0m2021.03.20 20:34:53 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition

  // start of val planets operation
  planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }
}

MÃ¤rz 20, 2021 8:35:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 25585
MÃ¤rz 20, 2021 8:36:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 25620
[0m2021.03.20 20:36:52 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition

  // start of val planets operation
  planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }
  /**
    * would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */
}

MÃ¤rz 20, 2021 8:37:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 195 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 195 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 195 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:37:36 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:37:38 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:37:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:37:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:37:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:37:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:37:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:37:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:37:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:37:48 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:37:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:37:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:37:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:37:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:37:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:37:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:37:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 194 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 194 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 194 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:14 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 195 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 195 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 195 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:20 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:22 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

[0m2021.03.20 20:38:24 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition

  // start of val planets operation
  planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for (let idx: number = 0; idx < (()))
    println(a * b)
  }
}

MÃ¤rz 20, 2021 8:38:40 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 194 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 194 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 194 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 26178
MÃ¤rz 20, 2021 8:38:42 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 26180
MÃ¤rz 20, 2021 8:38:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:49 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:52 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:38:59 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:13 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:17 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:21 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:23 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:26 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

[0m2021.03.20 20:39:30 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition

  // start of val planets operation
  planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ...
    println(a * b)
  }
}

MÃ¤rz 20, 2021 8:39:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:41 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:46 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:47 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:51 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:53 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:54 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:39:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:40:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:40:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:40:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:40:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:40:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:40:06 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:40:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:40:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:40:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 193 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

[0m2021.03.20 20:40:10 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition

  // start of val planets operation
  planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }
}

[0m2021.03.20 20:41:56 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition

  // start of val planets operation
  planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }
}

MÃ¤rz 20, 2021 8:42:01 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 203 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 203 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 203 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:42:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 203 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 203 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 203 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:42:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 206 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 206 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 206 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:42:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 206 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 206 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 206 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:42:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 205 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 205 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 205 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:42:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 194 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 194 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 194 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:42:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 194 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 194 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 194 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:42:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 194 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 194 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 194 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:42:09 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 194 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 194 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 194 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:42:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 198 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 198 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 198 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:42:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 198 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 198 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 198 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:42:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 198 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 198 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 198 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:42:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 198 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 198 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 198 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 8:42:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 197 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 197 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 197 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

[0m2021.03.20 20:42:25 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/
}

MÃ¤rz 20, 2021 8:42:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 207 is not a valid line number, allowed [0..192]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 207 is not a valid line number, allowed [0..192]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 207 is not a valid line number, allowed [0..192]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

[0m2021.03.20 20:42:43 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  val d = new D
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B
}

[0m2021.03.20 20:43:32 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B
}

[0m2021.03.20 20:45:47 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, probably most likely to be int
}

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/
}

MÃ¤rz 20, 2021 8:46:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 27155
MÃ¤rz 20, 2021 8:46:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 27156
[0m2021.03.20 20:46:23 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string)
}

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/
}

[0m2021.03.20 20:46:39 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/
}

MÃ¤rz 20, 2021 8:47:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 27364
MÃ¤rz 20, 2021 8:47:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 27430
MÃ¤rz 20, 2021 8:47:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 27542
MÃ¤rz 20, 2021 8:48:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 27893
[0m2021.03.20 20:49:07 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext = i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch = s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // ??
  }
}

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/
}

MÃ¤rz 20, 2021 8:49:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 28067
/*
 * Scala (https://www.scala-lang.org)
 *
 * Copyright EPFL and Lightbend, Inc.
 *
 * Licensed under Apache License 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 *
 * See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 */

// DO NOT EDIT, CHANGES WILL BE LOST
// This auto-generated code can be modified in "project/GenerateAnyVals.scala".
// Afterwards, running "sbt generateSources" regenerates this source file.

package scala


/** `Unit` is a subtype of [[scala.AnyVal]]. There is only one value of type
 *  `Unit`, `()`, and it is not represented by any object in the underlying
 *  runtime system. A method with return type `Unit` is analogous to a Java
 *  method which is declared `void`.
 */
final abstract class Unit private extends AnyVal {
  // Provide a more specific return type for Scaladoc
  override def getClass(): Class[Unit] = ???
}

object Unit extends AnyValCompanion {

  /** Transform a value type into a boxed reference type.
   *
   *  @param  x   the Unit to be boxed
   *  @return     a scala.runtime.BoxedUnit offering `x` as its underlying value.
   */
  def box(x: Unit): scala.runtime.BoxedUnit = scala.runtime.BoxedUnit.UNIT

  /** Transform a boxed type into a value type.  Note that this
   *  method is not typesafe: it accepts any Object, but will throw
   *  an exception if the argument is not a scala.runtime.BoxedUnit.
   *
   *  @param  x   the scala.runtime.BoxedUnit to be unboxed.
   *  @throws     ClassCastException  if the argument is not a scala.runtime.BoxedUnit
   *  @return     the Unit value ()
   */
  def unbox(x: java.lang.Object): Unit = x.asInstanceOf[scala.runtime.BoxedUnit]

  /** The String representation of the scala.Unit companion object. */
  override def toString = "object scala.Unit"
}


MÃ¤rz 20, 2021 8:50:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 28186
MÃ¤rz 20, 2021 8:50:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 28280
MÃ¤rz 20, 2021 8:50:34 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 28291
[0m2021.03.20 20:50:51 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext = i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch = s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // ??
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/
}

[0m2021.03.20 20:51:36 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext = i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch = s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // ??
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/
}

[0m2021.03.20 20:51:53 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // ??
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  val richStringIter = new RichStringIter
  richStringIter.foreach(println)
}

MÃ¤rz 20, 2021 8:52:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 28485
[0m2021.03.20 20:52:29 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  val richStringIter = new RichStringIter
  richStringIter.foreach(println)
}

[0m2021.03.20 20:53:02 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  val richStringIter = new RichStringIter
  richStringIter.foreach(println)
}

[0m2021.03.20 20:53:25 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  val richStringIter = new RichStringIter
  richStringIter.foreach(println)
}

[0m2021.03.20 20:56:59 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  val newSalaries = salaries.map(_ * 2)
}

[0m2021.03.20 20:57:28 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach((sal) => println(sal))
}

[0m2021.03.20 20:57:50 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))
}

[0m2021.03.20 20:58:26 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(println(_ * 2))
}

[0m2021.03.20 20:58:34 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))
}

MÃ¤rz 20, 2021 8:59:56 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 29210
[0m2021.03.20 21:00:23 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) = temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] = temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))
}

MÃ¤rz 20, 2021 9:01:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 29632
MÃ¤rz 20, 2021 9:01:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 29685
[0m2021.03.20 21:01:41 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) = temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] = temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  var temperature = WeeklyWeatherForecast(new Seq(10.00, 35.5))
  println(temperature)
}

MÃ¤rz 20, 2021 9:02:11 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 29757
MÃ¤rz 20, 2021 9:02:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 29794
MÃ¤rz 20, 2021 9:02:18 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 29809
[0m2021.03.20 21:02:27 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) = temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] = temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  var temperature = WeeklyWeatherForecast(10.00)
  println(temperature.forecastInFahrenheit)
}

MÃ¤rz 20, 2021 9:02:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 29858
MÃ¤rz 20, 2021 9:02:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 29860
[0m2021.03.20 21:02:50 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) = temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] = temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  var temperature = WeeklyWeatherForecast(new Seq(10.00))
  println(temperature.forecastInFahrenheit)
}

MÃ¤rz 20, 2021 9:03:02 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 29968
[0m2021.03.20 21:03:16 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) = temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] = temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  var temperature = WeeklyWeatherForecast(10.00)
  println(temperature.forecastInFahrenheit)
}

[0m2021.03.20 21:04:03 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) = temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] = temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  var temperature = WeeklyWeatherForecast(Seq(10.00))
  println(temperature.forecastInFahrenheit)
}

[0m2021.03.20 21:04:37 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) = temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] = temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  var temperature = WeeklyWeatherForecast(Seq(10.00))
  temperature.forecastInFahrenheit.map(println(_))
}

MÃ¤rz 20, 2021 9:04:50 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 30288
[0m2021.03.20 21:05:03 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) = temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] = temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))
}

MÃ¤rz 20, 2021 9:07:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 30418
[0m2021.03.20 21:07:52 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class urlBuilder {
  def urlBuilder(
      ssl: Boolean,
      domainName: String
  ): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))
}

[0m2021.03.20 21:08:42 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class urlBuilder {
  def urlBuilder(
      ssl: Boolean,
      domainName: String
  ): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  val domainName = "www.example.com"
  def getURL = new UrlBuilder().urlBuilder(ssl = true, domainName)
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
}

[0m2021.03.20 21:09:19 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class urlBuilder (ssl: Boolean, domainName: String) {
  def urlBuilder(
      ssl: Boolean,
      domainName: String
  ): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  val domainName = "www.example.com"
  def getURL = new UrlBuilder().urlBuilder(ssl = true, domainName)
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
}

MÃ¤rz 20, 2021 9:09:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 30802
[0m2021.03.20 21:10:29 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class urlBuilder (ssl: Boolean, domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  val domainName = "www.example.com"
  def getURL = new UrlBuilder(ssl = true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
}

[0m2021.03.20 21:11:32 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class urlBuilder (ssl: Boolean, domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /**
    * class urlBuilder (ssl: Boolean, domainName: String) {
  def urlBuilder(): (String, String) => String = {
    */
  val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
}

[0m2021.03.20 21:11:54 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class urlBuilder (var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /**
    * class urlBuilder (ssl: Boolean, domainName: String) {
  def urlBuilder(): (String, String) => String = {
    */
  val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
}

[0m2021.03.20 21:12:14 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder (var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /**
    * class urlBuilder (ssl: Boolean, domainName: String) {
  def urlBuilder(): (String, String) => String = {
    */
  val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
}

[0m2021.03.20 21:12:32 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder (var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /**
    * class urlBuilder (ssl: Boolean, domainName: String) {
  def urlBuilder(): (String, String) => String = {
    */
  val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String

  println(url)  
}

MÃ¤rz 20, 2021 9:12:57 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 31310
MÃ¤rz 20, 2021 9:12:58 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 31317
[0m2021.03.20 21:33:40 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  val circle1 = Circle(5.0)
  circle1.area
}

[0m2021.03.20 21:33:57 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  val circle1 = Circle(5.0)
  println(circle1.area)
}

[0m2021.03.20 21:35:11 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _ => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  val circle1 = Circle(5.0)
  println(circle1.area)
}

[0m2021.03.20 21:35:33 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }
}

[0m2021.03.20 21:36:10 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center_AT_epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }
}

[0m2021.03.20 21:36:27 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }
}

[0m2021.03.20 21:40:14 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._

import scala.util.Random

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }
}

MÃ¤rz 20, 2021 9:40:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 324 is not a valid line number, allowed [0..322]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 324 is not a valid line number, allowed [0..322]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 324 is not a valid line number, allowed [0..322]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 9:40:30 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: java.lang.IllegalArgumentException: 324 is not a valid line number, allowed [0..322]
java.util.concurrent.CompletionException: java.lang.IllegalArgumentException: 324 is not a valid line number, allowed [0..322]
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.IllegalArgumentException: 324 is not a valid line number, allowed [0..322]
	at scala.meta.internal.inputs.InternalInput.lineToOffset(InternalInput.scala:38)
	at scala.meta.internal.inputs.InternalInput.lineToOffset$(InternalInput.scala:33)
	at scala.meta.inputs.Input$VirtualFile.lineToOffset(Input.scala:80)
	at scala.meta.inputs.Position$Range$.apply(Position.scala:59)
	at scala.meta.internal.mtags.CommonMtagsEnrichments$XtensionLspRange.toMeta(CommonMtagsEnrichments.scala:183)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$5(InsertInferredType.scala:85)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.metals.codeactions.InsertInferredType.$anonfun$contribute$1(InsertInferredType.scala:84)
	at scala.concurrent.Future$.$anonfun$apply$1(Future.scala:659)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

[0m2021.03.20 21:40:38 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._

import scala.util.Random

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }
}

[0m2021.03.20 21:41:25 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._

import scala.util.Random

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID("Nico")
  val CustomerID(name) = customer2ID
  println(name) // prints Nico
}

[0m2021.03.20 21:42:43 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._

import scala.util.Random

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID("Nico") // new value "Nico" being operated on applied...
  val CustomerID(name) = customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)
}

[0m2021.03.20 21:43:30 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._

import scala.util.Random

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID("--asdfasdfasdf") // new value "Nico" being operated on applied...
  val CustomerID(name) = customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)
}

[0m2021.03.20 21:43:38 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._

import scala.util.Random

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID("-asdfasdfasdf") // new value "Nico" being operated on applied...
  val CustomerID(name) = customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)
}

[0m2021.03.20 21:44:36 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._

import scala.util.Random

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID("TEST-asdfasdfasdf") // new value "Nico" being operated on applied...
  val CustomerID(name) = customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)
}

[0m2021.03.20 21:44:42 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._

import scala.util.Random

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID("TEST--asdfasdfasdf") // new value "Nico" being operated on applied...
  val CustomerID(name) = customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)
}

[0m2021.03.20 21:46:02 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

case class User(name: String, age: Int)

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID("TEST--asdfasdfasdf") // new value "Nico" being operated on applied...
  val CustomerID(name) = customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)
}

[0m2021.03.20 21:46:28 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

case class User(name: String, age: Int)

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  /*val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println(_))*/

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis
}

MÃ¤rz 20, 2021 9:46:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 32301
MÃ¤rz 20, 2021 9:46:55 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 32302
[0m2021.03.20 21:47:00 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

case class User(name: String, age: Int)

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis
}

[0m2021.03.20 21:47:15 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
MÃ¤rz 20, 2021 9:49:43 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 32403
[0m2021.03.20 21:50:32 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

case class User(name: String, age: Int)

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      yield (i, j)

  foo(10, 10) foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }
}

/*
 * Scala (https://www.scala-lang.org)
 *
 * Copyright EPFL and Lightbend, Inc.
 *
 * Licensed under Apache License 2.0
 * (http://www.apache.org/licenses/LICENSE-2.0).
 *
 * See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 */

package scala
package runtime

import scala.collection.immutable.Range

// Note that this does not implement IntegralProxy[Int] so that it can return
// the Int-specific Range class from until/to.
final class RichInt(val self: Int) extends AnyVal with ScalaNumberProxy[Int] with RangedProxy[Int] {
  protected def num = scala.math.Numeric.IntIsIntegral
  protected def ord = scala.math.Ordering.Int

  override def doubleValue() = self.toDouble
  override def floatValue()  = self.toFloat
  override def longValue()   = self.toLong
  override def intValue()    = self
  override def byteValue()   = self.toByte
  override def shortValue()  = self.toShort

  /** Returns `'''true'''` if this number has no decimal component.
    * Always `'''true'''` for `RichInt`.
    */
  def isWhole() = true

  override def isValidInt   = true
  def isValidLong  = true

  override def abs: Int            = math.abs(self)
  override def max(that: Int): Int = math.max(self, that)
  override def min(that: Int): Int = math.min(self, that)
  override def signum: Int         = math.signum(self)

  /** There is no reason to round an `Int`, but this method is provided to avoid accidental loss of precision from a detour through `Float`. */
  @deprecated("this is an integer type; there is no reason to round it.  Perhaps you meant to call this on a floating-point value?", "2.11.0")
  def round: Int = self

  def toBinaryString: String = java.lang.Integer.toBinaryString(self)
  def toHexString: String    = java.lang.Integer.toHexString(self)
  def toOctalString: String  = java.lang.Integer.toOctalString(self)

  type ResultWithoutStep = Range

  /**
    * @param end The final bound of the range to make.
    * @return A [[scala.collection.immutable.Range]] from `this` up to but
    *         not including `end`.
    */
  def until(end: Int): Range = Range(self, end)

  /**
    * @param end The final bound of the range to make.
    * @param step The number to increase by for each step of the range.
    * @return A [[scala.collection.immutable.Range]] from `this` up to but
    *         not including `end`.
    */
  def until(end: Int, step: Int): Range = Range(self, end, step)

  /** like `until`, but includes the last index */
  /**
    * @param end The final bound of the range to make.
    * @return A [[scala.collection.immutable.Range]] from `'''this'''` up to
    *         and including `end`.
    */
  def to(end: Int): Range.Inclusive = Range.inclusive(self, end)

  /**
    * @param end The final bound of the range to make.
    * @param step The number to increase by for each step of the range.
    * @return A [[scala.collection.immutable.Range]] from `'''this'''` up to
    *         and including `end`.
    */
  def to(end: Int, step: Int): Range.Inclusive = Range.inclusive(self, end, step)
}

MÃ¤rz 20, 2021 9:51:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 32513
MÃ¤rz 20, 2021 9:51:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 32538
[0m2021.03.20 21:51:45 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
[0m2021.03.20 21:54:14 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

case class User(name: String, age: Int)

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)")
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 22:14:59 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import net.liftweb.json.JsonDSL._
import net.liftweb.json.JsonAST._
import net.liftweb.json.Printer._
import net.liftweb.json.JObject

case class User(name: String, age: Int)

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)")
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 22:15:59 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import net.liftweb.json._
import net.liftweb.json.JsonDSL._
import net.liftweb.json.JsonAST._
import net.liftweb.json.Printer._
import net.liftweb.json.JObject

case class User(name: String, age: Int)

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)")
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 22:17:17 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

case class User(name: String, age: Int)

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)")
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 22:17:23 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/build.sbt[0m
[0m2021.03.20 22:17:34 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/build.sbt[0m

// The simplest possible sbt build file is just one line:

scalaVersion := "2.13.3"
// That is, to create a valid sbt build, all you've got to do is define the
// version of Scala you'd like your project to use.

// ============================================================================

// Lines like the above defining `scalaVersion` are called "settings". Settings
// are key/value pairs. In the case of `scalaVersion`, the key is "scalaVersion"
// and the value is "2.13.3"

// It's possible to define many kinds of settings, such as:

name := "hello-world"
organization := "ch.epfl.scala"
version := "1.0"

// Note, it's not required for you to define these three settings. These are
// mostly only necessary if you intend to publish your library's binaries on a
// place like Sonatype or Bintray.


// Want to use a published library in your project?
// You can define other libraries as dependencies in your build like this:

libraryDependencies += "org.scala-lang.modules" %% "scala-parser-combinators" % "1.1.2"
libraryDependencies += "io.spray" %%  "spray-json" % "1.3.6"

// Here, `libraryDependencies` is a set of dependencies, and by using `+=`,
// we're adding the scala-parser-combinators dependency to the set of dependencies
// that sbt will go and fetch when it starts up.
// Now, in any Scala file, you can import classes, objects, etc., from
// scala-parser-combinators with a regular import.

// TIP: To find the "dependency" that you need to add to the
// `libraryDependencies` set, which in the above example looks like this:

// "org.scala-lang.modules" %% "scala-parser-combinators" % "1.1.2"

// You can use Scaladex, an index of all known published Scala libraries. There,
// after you find the library you want, you can just copy/paste the dependency
// information that you need into your build file. For example, on the
// scala/scala-parser-combinators Scaladex page,
// https://index.scala-lang.org/scala/scala-parser-combinators, you can copy/paste
// the sbt dependency from the sbt box on the right-hand side of the screen.

// IMPORTANT NOTE: while build files look _kind of_ like regular Scala, it's
// important to note that syntax in *.sbt files doesn't always behave like
// regular Scala. For example, notice in this build file that it's not required
// to put our settings into an enclosing object or class. Always remember that
// sbt is a bit different, semantically, than vanilla Scala.

// ============================================================================

// Most moderately interesting Scala projects don't make use of the very simple
// build file style (called "bare style") used in this build.sbt file. Most
// intermediate Scala projects make use of so-called "multi-project" builds. A
// multi-project build makes it possible to have different folders which sbt can
// be configured differently for. That is, you may wish to have different
// dependencies or different testing frameworks defined for different parts of
// your codebase. Multi-project builds make this possible.

// Here's a quick glimpse of what a multi-project build looks like for this
// build, with only one "subproject" defined, called `root`:

// lazy val root = (project in file(".")).
//   settings(
//     inThisBuild(List(
//       organization := "ch.epfl.scala",
//       scalaVersion := "2.13.3"
//     )),
//     name := "hello-world"
//   )

// To learn more about multi-project builds, head over to the official sbt
// documentation at http://www.scala-sbt.org/documentation.html

MÃ¤rz 20, 2021 10:18:16 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 32900
[0m2021.03.20 22:18:25 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import spray.json._
import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)

case class User(name: String, age: Int)

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)")
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 22:19:04 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import spray.json._
import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)

case class User(name: String, age: Int)

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

MÃ¤rz 20, 2021 10:19:23 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: offset 10417, count -150, length 10422
MÃ¤rz 20, 2021 10:19:23 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: offset 10419, count -150, length 10424
[0m2021.03.20 22:19:28 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import spray.json._
import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)

case class User(name: String, age: Int)

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      // println(s"($i, $j)".toJson)
      yield (i, j)

  foo(10, 10).toJson/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 22:19:47 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import spray.json._
import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)

case class User(name: String, age: Int)

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 22:20:21 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import spray.json._
import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)

case class User(name: String, age: Int)

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  ).toJson

  println(userBase)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 22:22:38 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import spray.json._
import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)

case class User(name: String, age: Int)

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(Json.toJson(userBase))

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 22:23:43 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import spray.json._
import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)

case class User(name: String, age: Int)

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(Json.obj("users" -> userBase))

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 22:24:12 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import spray.json._
import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import play.api.libs.json._
import play.api.libs.json._

case class User(name: String, age: Int)

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(Json.obj("users" -> userBase))

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 22:24:18 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import spray.json._
import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)

case class User(name: String, age: Int)

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(Json.obj("users" -> userBase))

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 22:25:24 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import spray.json._
import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)

case class User(name: String, age: Int)

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(("users" -> userBase).toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 22:27:13 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import spray.json._
import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit val userFormat = jsonFormat4(User)
}

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(("users" -> userBase))

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 22:28:15 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import spray.json._
import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit val userFormat = jsonFormat4(User)
}

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 22:29:15 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import spray.json._
import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit val userFormat = jsonFormat4(User)
}

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 22:29:41 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

/*import spray.json._
import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyJsonProtocol._*/

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit val userFormat = jsonFormat4(User)
}

import spray.json._
import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyJsonProtocol._

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

MÃ¤rz 20, 2021 10:30:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 34132
[0m2021.03.20 22:30:25 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import spray.json._
import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit val userFormat = jsonFormat4(User)
}

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 22:30:50 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import spray.json._
import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit val userFormat = jsonFormat4(User)
}

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

MÃ¤rz 20, 2021 10:31:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 34260
MÃ¤rz 20, 2021 10:31:25 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 34261
[0m2021.03.20 22:31:28 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import spray.json._
import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit val userFormat = jsonFormat4(User)
}

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 22:32:44 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit val userFormat = jsonFormat4(User)
}

import spray.json._
import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 22:33:04 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit val userFormat = jsonFormat4(User)
}

import spray.json._
import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 22:33:31 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit val userFormat = jsonFormat4(User)
}

import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

MÃ¤rz 20, 2021 10:33:45 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 34511
[0m2021.03.20 22:33:46 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit val userFormat = jsonFormat4(User)
}

import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 22:36:04 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit val userFormat = jsonFormat4(User)
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

MÃ¤rz 20, 2021 10:36:15 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 34612
[0m2021.03.20 22:36:29 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import spray.json._
import spray.httpx.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit val userFormat = jsonFormat4(User)
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 22:36:39 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit val userFormat = jsonFormat4(User)
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
      // yield (i, j)

  foo(10, 10)/* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

MÃ¤rz 20, 2021 10:39:10 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint fallbackResponseError
SEVERE: Internal error: org.scalameta.invariants.InvariantFailedException: invariant failed:
when verifying scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable
found that scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable is false
where tpe = (name, red.toInt, green.toInt, blue.toInt)
java.util.concurrent.CompletionException: org.scalameta.invariants.InvariantFailedException: invariant failed:
when verifying scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable
found that scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable is false
where tpe = (name, red.toInt, green.toInt, blue.toInt)
	at java.base/java.util.concurrent.CompletableFuture.encodeThrowable(CompletableFuture.java:331)
	at java.base/java.util.concurrent.CompletableFuture.completeThrowable(CompletableFuture.java:346)
	at java.base/java.util.concurrent.CompletableFuture$UniAccept.tryFire(CompletableFuture.java:704)
	at java.base/java.util.concurrent.CompletableFuture.postComplete(CompletableFuture.java:506)
	at java.base/java.util.concurrent.CompletableFuture.completeExceptionally(CompletableFuture.java:2158)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1(CancelTokens.scala:40)
	at scala.meta.internal.metals.CancelTokens$.$anonfun$future$1$adapted(CancelTokens.scala:38)
	at scala.concurrent.impl.CallbackRunnable.run(Promise.scala:64)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: org.scalameta.invariants.InvariantFailedException: invariant failed:
when verifying scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable
found that scala.meta.internal.trees.`package`.XtensionTreesType(tpe).isConstructable is false
where tpe = (name, red.toInt, green.toInt, blue.toInt)
	at org.scalameta.invariants.InvariantFailedException$.raise(Exceptions.scala:19)
	at scala.meta.Init$.internal$261(Trees.scala:476)
	at scala.meta.Init$.apply(Trees.scala:475)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$initRest$1(ScalametaParser.scala:4562)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.initRest(ScalametaParser.scala:4546)
	at scala.meta.internal.parsers.ScalametaParser.initInsideTemplate(ScalametaParser.scala:4534)
	at scala.meta.internal.parsers.ScalametaParser.init(ScalametaParser.scala:4611)
	at scala.meta.internal.parsers.ScalametaParser.templateParents(ScalametaParser.scala:4621)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4663)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$4(ScalametaParser.scala:2807)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$simpleExpr0$1(ScalametaParser.scala:2807)
	at scala.meta.internal.parsers.ScalametaParser.atPosTry(ScalametaParser.scala:809)
	at scala.meta.internal.parsers.ScalametaParser.autoPosTry(ScalametaParser.scala:819)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr0(ScalametaParser.scala:2772)
	at scala.meta.internal.parsers.ScalametaParser.simpleExpr(ScalametaParser.scala:2770)
	at scala.meta.internal.parsers.ScalametaParser.prefixExpr(ScalametaParser.scala:2754)
	at scala.meta.internal.parsers.ScalametaParser.postfixExpr(ScalametaParser.scala:2734)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$14(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2311)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$blockStatSeq$2(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.stat(ScalametaParser.scala:4787)
	at scala.meta.internal.parsers.ScalametaParser.blockStatSeq(ScalametaParser.scala:4944)
	at scala.meta.internal.parsers.ScalametaParser.parseStatSeq$1(ScalametaParser.scala:3014)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$caseClause$1(ScalametaParser.scala:3022)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.caseClause(ScalametaParser.scala:3006)
	at scala.meta.internal.parsers.ScalametaParser.caseClauses(ScalametaParser.scala:3049)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$4(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrError(ScalametaParser.scala:719)
	at scala.meta.internal.parsers.ScalametaParser.inBracesOrNil(ScalametaParser.scala:739)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$matchClause$3(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.matchClause(ScalametaParser.scala:2155)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$expr$2(ScalametaParser.scala:2338)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2197)
	at scala.meta.internal.parsers.ScalametaParser.expr(ScalametaParser.scala:2092)
	at scala.meta.internal.parsers.ScalametaParser.exprMaybeIndented(ScalametaParser.scala:2120)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$funDefRest$1(ScalametaParser.scala:4236)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.funDefRest(ScalametaParser.scala:4178)
	at scala.meta.internal.parsers.ScalametaParser.funDefOrDclOrExtensionOrSecondaryCtor(ScalametaParser.scala:4107)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3963)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.defOrDclOrSecondaryCtor(ScalametaParser.scala:3977)
	at scala.meta.internal.parsers.ScalametaParser.nonLocalDefOrDcl(ScalametaParser.scala:3948)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4868)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$templateStat$1$1.applyOrElse(ScalametaParser.scala:4862)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.templateStats(ScalametaParser.scala:4878)
	at scala.meta.internal.parsers.ScalametaParser.templateStatSeq(ScalametaParser.scala:4858)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$templateBody$1(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.inBraces(ScalametaParser.scala:712)
	at scala.meta.internal.parsers.ScalametaParser.templateBody(ScalametaParser.scala:4707)
	at scala.meta.internal.parsers.ScalametaParser.templateBodyOpt(ScalametaParser.scala:4715)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4645)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$template$1(ScalametaParser.scala:4664)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.template(ScalametaParser.scala:4649)
	at scala.meta.internal.parsers.ScalametaParser.templateOpt(ScalametaParser.scala:4690)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$objectDef$1(ScalametaParser.scala:4439)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.objectDef(ScalametaParser.scala:4431)
	at scala.meta.internal.parsers.ScalametaParser.tmplDef(ScalametaParser.scala:4315)
	at scala.meta.internal.parsers.ScalametaParser.topLevelTmplDef(ScalametaParser.scala:4297)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4828)
	at scala.meta.internal.parsers.ScalametaParser$$anonfun$topStat$1.applyOrElse(ScalametaParser.scala:4816)
	at scala.runtime.AbstractPartialFunction.apply(AbstractPartialFunction.scala:38)
	at scala.meta.internal.parsers.ScalametaParser.statSeq(ScalametaParser.scala:4806)
	at scala.meta.internal.parsers.ScalametaParser.topStatSeq(ScalametaParser.scala:4815)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$batchSource$1(ScalametaParser.scala:5029)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.batchSource(ScalametaParser.scala:4995)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$source$1(ScalametaParser.scala:4978)
	at scala.meta.internal.parsers.ScalametaParser.atPos(ScalametaParser.scala:800)
	at scala.meta.internal.parsers.ScalametaParser.autoPos(ScalametaParser.scala:816)
	at scala.meta.internal.parsers.ScalametaParser.source(ScalametaParser.scala:4977)
	at scala.meta.internal.parsers.ScalametaParser.entrypointSource(ScalametaParser.scala:4983)
	at scala.meta.internal.parsers.ScalametaParser.$anonfun$parseSource$2(ScalametaParser.scala:142)
	at scala.meta.internal.parsers.ScalametaParser.parseRule(ScalametaParser.scala:52)
	at scala.meta.internal.parsers.ScalametaParser.parseSource(ScalametaParser.scala:142)
	at scala.meta.parsers.Parse$.$anonfun$parseSource$1(Parse.scala:29)
	at scala.meta.internal.parsers.ScalametaParser$$anon$257.apply(ScalametaParser.scala:5040)
	at scala.meta.parsers.Api$XtensionParseDialectInput.parse(Api.scala:25)
	at scala.meta.internal.parsing.Trees.$anonfun$parse$2(Trees.scala:80)
	at scala.Option.map(Option.scala:230)
	at scala.meta.internal.parsing.Trees.parse(Trees.scala:77)
	at scala.meta.internal.parsing.Trees.didChange(Trees.scala:49)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$parseTreesAndPublishDiags$2(MetalsLanguageServer.scala:271)
	at scala.meta.internal.metals.MetalsLanguageServer.$anonfun$parseTreesAndPublishDiags$2$adapted(MetalsLanguageServer.scala:270)
	at scala.util.Success.$anonfun$map$1(Try.scala:255)
	at scala.util.Success.map(Try.scala:213)
	at scala.concurrent.Future.$anonfun$map$1(Future.scala:292)
	at scala.concurrent.impl.Promise.liftedTree1$1(Promise.scala:33)
	at scala.concurrent.impl.Promise.$anonfun$transform$1(Promise.scala:33)
	... 4 more

MÃ¤rz 20, 2021 10:39:24 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 35003
[0m2021.03.20 22:39:37 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 22:40:19 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

MÃ¤rz 20, 2021 10:40:37 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 35162
[0m2021.03.20 22:40:44 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

MÃ¤rz 20, 2021 10:45:12 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 35220
[0m2021.03.20 22:45:26 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/build.sbt[0m
// The simplest possible sbt build file is just one line:

scalaVersion := "2.13.3"
// That is, to create a valid sbt build, all you've got to do is define the
// version of Scala you'd like your project to use.

// ============================================================================

// Lines like the above defining `scalaVersion` are called "settings". Settings
// are key/value pairs. In the case of `scalaVersion`, the key is "scalaVersion"
// and the value is "2.13.3"

// It's possible to define many kinds of settings, such as:

name := "hello-world"
organization := "ch.epfl.scala"
version := "1.0"

// Note, it's not required for you to define these three settings. These are
// mostly only necessary if you intend to publish your library's binaries on a
// place like Sonatype or Bintray.

// Want to use a published library in your project?
// You can define other libraries as dependencies in your build like this:

libraryDependencies += "org.scala-lang.modules" %% "scala-parser-combinators" % "1.1.2"
libraryDependencies += "io.spray" %% "spray-json" % "1.3.6"

val AkkaVersion = "2.6.8"
val AkkaHttpVersion = "10.2.4"
libraryDependencies ++= Seq(
  "com.typesafe.akka" %% "akka-actor-typed" % AkkaVersion,
  "com.typesafe.akka" %% "akka-stream" % AkkaVersion,
  "com.typesafe.akka" %% "akka-http" % AkkaHttpVersion
)

// Here, `libraryDependencies` is a set of dependencies, and by using `+=`,
// we're adding the scala-parser-combinators dependency to the set of dependencies
// that sbt will go and fetch when it starts up.
// Now, in any Scala file, you can import classes, objects, etc., from
// scala-parser-combinators with a regular import.

// TIP: To find the "dependency" that you need to add to the
// `libraryDependencies` set, which in the above example looks like this:

// "org.scala-lang.modules" %% "scala-parser-combinators" % "1.1.2"

// You can use Scaladex, an index of all known published Scala libraries. There,
// after you find the library you want, you can just copy/paste the dependency
// information that you need into your build file. For example, on the
// scala/scala-parser-combinators Scaladex page,
// https://index.scala-lang.org/scala/scala-parser-combinators, you can copy/paste
// the sbt dependency from the sbt box on the right-hand side of the screen.

// IMPORTANT NOTE: while build files look _kind of_ like regular Scala, it's
// important to note that syntax in *.sbt files doesn't always behave like
// regular Scala. For example, notice in this build file that it's not required
// to put our settings into an enclosing object or class. Always remember that
// sbt is a bit different, semantically, than vanilla Scala.

// ============================================================================

// Most moderately interesting Scala projects don't make use of the very simple
// build file style (called "bare style") used in this build.sbt file. Most
// intermediate Scala projects make use of so-called "multi-project" builds. A
// multi-project build makes it possible to have different folders which sbt can
// be configured differently for. That is, you may wish to have different
// dependencies or different testing frameworks defined for different parts of
// your codebase. Multi-project builds make this possible.

// Here's a quick glimpse of what a multi-project build looks like for this
// build, with only one "subproject" defined, called `root`:

// lazy val root = (project in file(".")).
//   settings(
//     inThisBuild(List(
//       organization := "ch.epfl.scala",
//       scalaVersion := "2.13.3"
//     )),
//     name := "hello-world"
//   )

// To learn more about multi-project builds, head over to the official sbt
// documentation at http://www.scala-sbt.org/documentation.html

MÃ¤rz 20, 2021 10:46:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 35260
[0m2021.03.20 22:46:38 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

MÃ¤rz 20, 2021 10:47:29 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 35454
MÃ¤rz 20, 2021 10:47:39 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 35482
[0m2021.03.20 22:47:54 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(HttpEntity(ContentTypes.`text/html(UTF-8)`, "<h1>Say hello to akka-http</h1>"))
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(s"Server online at http://scala.localnet:8080/\nPress RETURN to stop...")
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}

import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

MÃ¤rz 20, 2021 10:49:03 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 35638
MÃ¤rz 20, 2021 10:49:07 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 35671
[0m2021.03.20 22:49:09 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(HttpEntity(ContentTypes.`text/html(UTF-8)`, "<h1>Say hello to akka-http</h1>"))
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(s"Server online at http://scala.localnet:8080/\nPress RETURN to stop...")
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}

import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

MÃ¤rz 20, 2021 10:50:48 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: offset 903, count -21, length 12478
MÃ¤rz 20, 2021 10:50:49 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: offset 909, count -21, length 12484
MÃ¤rz 20, 2021 10:50:49 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: offset 911, count -21, length 12486
MÃ¤rz 20, 2021 10:50:49 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: offset 912, count -21, length 12487
MÃ¤rz 20, 2021 10:50:52 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: offset 910, count -16, length 12485
[0m2021.03.20 22:51:11 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json(UTF-8)`,
              userBase.toJson
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}

import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 22:53:07 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json(UTF-8)`,
              userBase.toJson
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

MÃ¤rz 20, 2021 10:55:00 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 35975
[0m2021.03.20 22:55:15 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/build.sbt[0m
// The simplest possible sbt build file is just one line:

scalaVersion := "2.13.3"
// That is, to create a valid sbt build, all you've got to do is define the
// version of Scala you'd like your project to use.

// ============================================================================

// Lines like the above defining `scalaVersion` are called "settings". Settings
// are key/value pairs. In the case of `scalaVersion`, the key is "scalaVersion"
// and the value is "2.13.3"

// It's possible to define many kinds of settings, such as:

name := "hello-world"
organization := "ch.epfl.scala"
version := "1.0"

// Note, it's not required for you to define these three settings. These are
// mostly only necessary if you intend to publish your library's binaries on a
// place like Sonatype or Bintray.

// Want to use a published library in your project?
// You can define other libraries as dependencies in your build like this:

libraryDependencies += "org.scala-lang.modules" %% "scala-parser-combinators" % "1.1.2"
libraryDependencies += "io.spray" %% "spray-json" % "1.3.6"

val AkkaVersion = "2.6.8"
val AkkaHttpVersion = "10.2.4"
libraryDependencies ++= Seq(
  "com.typesafe.akka" %% "akka-actor-typed" % AkkaVersion,
  "com.typesafe.akka" %% "akka-stream" % AkkaVersion,
  "com.typesafe.akka" %% "akka-http" % AkkaHttpVersion
)

val AkkaHttpVersion = "10.2.4"
libraryDependencies += "com.typesafe.akka" %% "akka-http-spray-json" % AkkaHttpVersion

// Here, `libraryDependencies` is a set of dependencies, and by using `+=`,
// we're adding the scala-parser-combinators dependency to the set of dependencies
// that sbt will go and fetch when it starts up.
// Now, in any Scala file, you can import classes, objects, etc., from
// scala-parser-combinators with a regular import.

// TIP: To find the "dependency" that you need to add to the
// `libraryDependencies` set, which in the above example looks like this:

// "org.scala-lang.modules" %% "scala-parser-combinators" % "1.1.2"

// You can use Scaladex, an index of all known published Scala libraries. There,
// after you find the library you want, you can just copy/paste the dependency
// information that you need into your build file. For example, on the
// scala/scala-parser-combinators Scaladex page,
// https://index.scala-lang.org/scala/scala-parser-combinators, you can copy/paste
// the sbt dependency from the sbt box on the right-hand side of the screen.

// IMPORTANT NOTE: while build files look _kind of_ like regular Scala, it's
// important to note that syntax in *.sbt files doesn't always behave like
// regular Scala. For example, notice in this build file that it's not required
// to put our settings into an enclosing object or class. Always remember that
// sbt is a bit different, semantically, than vanilla Scala.

// ============================================================================

// Most moderately interesting Scala projects don't make use of the very simple
// build file style (called "bare style") used in this build.sbt file. Most
// intermediate Scala projects make use of so-called "multi-project" builds. A
// multi-project build makes it possible to have different folders which sbt can
// be configured differently for. That is, you may wish to have different
// dependencies or different testing frameworks defined for different parts of
// your codebase. Multi-project builds make this possible.

// Here's a quick glimpse of what a multi-project build looks like for this
// build, with only one "subproject" defined, called `root`:

// lazy val root = (project in file(".")).
//   settings(
//     inThisBuild(List(
//       organization := "ch.epfl.scala",
//       scalaVersion := "2.13.3"
//     )),
//     name := "hello-world"
//   )

// To learn more about multi-project builds, head over to the official sbt
// documentation at http://www.scala-sbt.org/documentation.html

[0m2021.03.20 22:55:36 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/build.sbt[0m
// The simplest possible sbt build file is just one line:

scalaVersion := "2.13.3"
// That is, to create a valid sbt build, all you've got to do is define the
// version of Scala you'd like your project to use.

// ============================================================================

// Lines like the above defining `scalaVersion` are called "settings". Settings
// are key/value pairs. In the case of `scalaVersion`, the key is "scalaVersion"
// and the value is "2.13.3"

// It's possible to define many kinds of settings, such as:

name := "hello-world"
organization := "ch.epfl.scala"
version := "1.0"

// Note, it's not required for you to define these three settings. These are
// mostly only necessary if you intend to publish your library's binaries on a
// place like Sonatype or Bintray.

// Want to use a published library in your project?
// You can define other libraries as dependencies in your build like this:

libraryDependencies += "org.scala-lang.modules" %% "scala-parser-combinators" % "1.1.2"
libraryDependencies += "io.spray" %% "spray-json" % "1.3.6"

val AkkaVersion = "2.6.8"
val AkkaHttpVersion = "10.2.4"
libraryDependencies ++= Seq(
  "com.typesafe.akka" %% "akka-actor-typed" % AkkaVersion,
  "com.typesafe.akka" %% "akka-stream" % AkkaVersion,
  "com.typesafe.akka" %% "akka-http" % AkkaHttpVersion
)

libraryDependencies += "com.typesafe.akka" %% "akka-http-spray-json" % AkkaHttpVersion

// Here, `libraryDependencies` is a set of dependencies, and by using `+=`,
// we're adding the scala-parser-combinators dependency to the set of dependencies
// that sbt will go and fetch when it starts up.
// Now, in any Scala file, you can import classes, objects, etc., from
// scala-parser-combinators with a regular import.

// TIP: To find the "dependency" that you need to add to the
// `libraryDependencies` set, which in the above example looks like this:

// "org.scala-lang.modules" %% "scala-parser-combinators" % "1.1.2"

// You can use Scaladex, an index of all known published Scala libraries. There,
// after you find the library you want, you can just copy/paste the dependency
// information that you need into your build file. For example, on the
// scala/scala-parser-combinators Scaladex page,
// https://index.scala-lang.org/scala/scala-parser-combinators, you can copy/paste
// the sbt dependency from the sbt box on the right-hand side of the screen.

// IMPORTANT NOTE: while build files look _kind of_ like regular Scala, it's
// important to note that syntax in *.sbt files doesn't always behave like
// regular Scala. For example, notice in this build file that it's not required
// to put our settings into an enclosing object or class. Always remember that
// sbt is a bit different, semantically, than vanilla Scala.

// ============================================================================

// Most moderately interesting Scala projects don't make use of the very simple
// build file style (called "bare style") used in this build.sbt file. Most
// intermediate Scala projects make use of so-called "multi-project" builds. A
// multi-project build makes it possible to have different folders which sbt can
// be configured differently for. That is, you may wish to have different
// dependencies or different testing frameworks defined for different parts of
// your codebase. Multi-project builds make this possible.

// Here's a quick glimpse of what a multi-project build looks like for this
// build, with only one "subproject" defined, called `root`:

// lazy val root = (project in file(".")).
//   settings(
//     inThisBuild(List(
//       organization := "ch.epfl.scala",
//       scalaVersion := "2.13.3"
//     )),
//     name := "hello-world"
//   )

// To learn more about multi-project builds, head over to the official sbt
// documentation at http://www.scala-sbt.org/documentation.html

MÃ¤rz 20, 2021 10:56:35 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 36022
MÃ¤rz 20, 2021 10:57:28 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: offset 1788, count -21, length 12462
MÃ¤rz 20, 2021 10:57:29 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: offset 1790, count -21, length 12464
MÃ¤rz 20, 2021 10:57:31 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: offset 1787, count -16, length 12461
MÃ¤rz 20, 2021 10:57:31 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: offset 1791, count -16, length 12465
[0m2021.03.20 22:57:33 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`text/plain(UTF-8)`,
              userBase.toJson
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

MÃ¤rz 20, 2021 10:58:12 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: offset 1787, count -16, length 12461
[0m2021.03.20 22:58:14 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`text/html(UTF-8)`,
              userBase.toJson
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 22:58:42 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`text/html(UTF-8)`,
              "<h1>Say hello to akka-http</h1>"
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:00:47 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/build.sbt[0m
// The simplest possible sbt build file is just one line:

scalaVersion := "2.13.3"
// That is, to create a valid sbt build, all you've got to do is define the
// version of Scala you'd like your project to use.

// ============================================================================

// Lines like the above defining `scalaVersion` are called "settings". Settings
// are key/value pairs. In the case of `scalaVersion`, the key is "scalaVersion"
// and the value is "2.13.3"

// It's possible to define many kinds of settings, such as:

name := "hello-world"
organization := "ch.epfl.scala"
version := "1.0"

// Note, it's not required for you to define these three settings. These are
// mostly only necessary if you intend to publish your library's binaries on a
// place like Sonatype or Bintray.

// Want to use a published library in your project?
// You can define other libraries as dependencies in your build like this:

libraryDependencies += "org.scala-lang.modules" %% "scala-parser-combinators" % "1.1.2"
libraryDependencies += "io.spray" %% "spray-json" % "1.3.6"

val AkkaVersion = "2.6.8"
val AkkaHttpVersion = "10.2.4"
libraryDependencies ++= Seq(
  "com.typesafe.akka" %% "akka-actor-typed" % AkkaVersion,
  "com.typesafe.akka" %% "akka-stream" % AkkaVersion,
  "com.typesafe.akka" %% "akka-http" % AkkaHttpVersion,
  "com.typesafe.akka" %% "akka-http-spray-json" % AkkaHttpVersion
)

// Here, `libraryDependencies` is a set of dependencies, and by using `+=`,
// we're adding the scala-parser-combinators dependency to the set of dependencies
// that sbt will go and fetch when it starts up.
// Now, in any Scala file, you can import classes, objects, etc., from
// scala-parser-combinators with a regular import.

// TIP: To find the "dependency" that you need to add to the
// `libraryDependencies` set, which in the above example looks like this:

// "org.scala-lang.modules" %% "scala-parser-combinators" % "1.1.2"

// You can use Scaladex, an index of all known published Scala libraries. There,
// after you find the library you want, you can just copy/paste the dependency
// information that you need into your build file. For example, on the
// scala/scala-parser-combinators Scaladex page,
// https://index.scala-lang.org/scala/scala-parser-combinators, you can copy/paste
// the sbt dependency from the sbt box on the right-hand side of the screen.

// IMPORTANT NOTE: while build files look _kind of_ like regular Scala, it's
// important to note that syntax in *.sbt files doesn't always behave like
// regular Scala. For example, notice in this build file that it's not required
// to put our settings into an enclosing object or class. Always remember that
// sbt is a bit different, semantically, than vanilla Scala.

// ============================================================================

// Most moderately interesting Scala projects don't make use of the very simple
// build file style (called "bare style") used in this build.sbt file. Most
// intermediate Scala projects make use of so-called "multi-project" builds. A
// multi-project build makes it possible to have different folders which sbt can
// be configured differently for. That is, you may wish to have different
// dependencies or different testing frameworks defined for different parts of
// your codebase. Multi-project builds make this possible.

// Here's a quick glimpse of what a multi-project build looks like for this
// build, with only one "subproject" defined, called `root`:

// lazy val root = (project in file(".")).
//   settings(
//     inThisBuild(List(
//       organization := "ch.epfl.scala",
//       scalaVersion := "2.13.3"
//     )),
//     name := "hello-world"
//   )

// To learn more about multi-project builds, head over to the official sbt
// documentation at http://www.scala-sbt.org/documentation.html

MÃ¤rz 20, 2021 11:01:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 36175
[0m2021.03.20 23:01:41 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`text/html(UTF-8)`,
              "<h1>Say hello to akka-http</h1>"
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

MÃ¤rz 20, 2021 11:05:04 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 36310
[0m2021.03.20 23:07:09 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              "<h1>Say hello to akka-http</h1>"
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:07:38 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              userBase.toJson
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:08:17 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              userBase.toJson.toString()
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:09:24 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              userBase.toJson.toString()
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object Main extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:09:55 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              userBase.toJson.toString()
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain extends App {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:10:10 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              userBase.toJson.toString()
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

MÃ¤rz 20, 2021 11:20:37 PM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
[0m2021.03.20 23:23:00 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/build.sbt[0m
[0m2021.03.20 23:23:09 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/build.sbt[0m
// The simplest possible sbt build file is just one line:

scalaVersion := "2.13.3"
// That is, to create a valid sbt build, all you've got to do is define the
// version of Scala you'd like your project to use.

// ============================================================================

// Lines like the above defining `scalaVersion` are called "settings". Settings
// are key/value pairs. In the case of `scalaVersion`, the key is "scalaVersion"
// and the value is "2.13.3"

// It's possible to define many kinds of settings, such as:

name := "hello-world"
organization := "ch.epfl.scala"
version := "1.0"

// Note, it's not required for you to define these three settings. These are
// mostly only necessary if you intend to publish your library's binaries on a
// place like Sonatype or Bintray.

// Want to use a published library in your project?
// You can define other libraries as dependencies in your build like this:

libraryDependencies += "org.scala-lang.modules" %% "scala-parser-combinators" % "1.1.2"
libraryDependencies += "io.spray" %% "spray-json" % "1.3.6"

val AkkaVersion = "2.6.8"
val AkkaHttpVersion = "10.2.4"
libraryDependencies ++= Seq(
  "com.typesafe.akka" %% "akka-actor-typed" % AkkaVersion,
  "com.typesafe.akka" %% "akka-stream" % AkkaVersion,
  "com.typesafe.akka" %% "akka-http" % AkkaHttpVersion,
  "com.typesafe.akka" %% "akka-http-spray-json" % AkkaHttpVersion
)

libraryDependencies += "mysql" % "mysql-connector-java" % "5.1.24"

// Here, `libraryDependencies` is a set of dependencies, and by using `+=`,
// we're adding the scala-parser-combinators dependency to the set of dependencies
// that sbt will go and fetch when it starts up.
// Now, in any Scala file, you can import classes, objects, etc., from
// scala-parser-combinators with a regular import.

// TIP: To find the "dependency" that you need to add to the
// `libraryDependencies` set, which in the above example looks like this:

// "org.scala-lang.modules" %% "scala-parser-combinators" % "1.1.2"

// You can use Scaladex, an index of all known published Scala libraries. There,
// after you find the library you want, you can just copy/paste the dependency
// information that you need into your build file. For example, on the
// scala/scala-parser-combinators Scaladex page,
// https://index.scala-lang.org/scala/scala-parser-combinators, you can copy/paste
// the sbt dependency from the sbt box on the right-hand side of the screen.

// IMPORTANT NOTE: while build files look _kind of_ like regular Scala, it's
// important to note that syntax in *.sbt files doesn't always behave like
// regular Scala. For example, notice in this build file that it's not required
// to put our settings into an enclosing object or class. Always remember that
// sbt is a bit different, semantically, than vanilla Scala.

// ============================================================================

// Most moderately interesting Scala projects don't make use of the very simple
// build file style (called "bare style") used in this build.sbt file. Most
// intermediate Scala projects make use of so-called "multi-project" builds. A
// multi-project build makes it possible to have different folders which sbt can
// be configured differently for. That is, you may wish to have different
// dependencies or different testing frameworks defined for different parts of
// your codebase. Multi-project builds make this possible.

// Here's a quick glimpse of what a multi-project build looks like for this
// build, with only one "subproject" defined, called `root`:

// lazy val root = (project in file(".")).
//   settings(
//     inThisBuild(List(
//       organization := "ch.epfl.scala",
//       scalaVersion := "2.13.3"
//     )),
//     name := "hello-world"
//   )

// To learn more about multi-project builds, head over to the official sbt
// documentation at http://www.scala-sbt.org/documentation.html

[0m2021.03.20 23:24:39 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/build.sbt[0m
// The simplest possible sbt build file is just one line:

scalaVersion := "2.13.3"
// That is, to create a valid sbt build, all you've got to do is define the
// version of Scala you'd like your project to use.

// ============================================================================

// Lines like the above defining `scalaVersion` are called "settings". Settings
// are key/value pairs. In the case of `scalaVersion`, the key is "scalaVersion"
// and the value is "2.13.3"

// It's possible to define many kinds of settings, such as:

name := "hello-world"
organization := "ch.epfl.scala"
version := "1.0"

// Note, it's not required for you to define these three settings. These are
// mostly only necessary if you intend to publish your library's binaries on a
// place like Sonatype or Bintray.

// Want to use a published library in your project?
// You can define other libraries as dependencies in your build like this:

libraryDependencies += "org.scala-lang.modules" %% "scala-parser-combinators" % "1.1.2"
libraryDependencies += "io.spray" %% "spray-json" % "1.3.6"

val AkkaVersion = "2.6.8"
val AkkaHttpVersion = "10.2.4"
libraryDependencies ++= Seq(
  "com.typesafe.akka" %% "akka-actor-typed" % AkkaVersion,
  "com.typesafe.akka" %% "akka-stream" % AkkaVersion,
  "com.typesafe.akka" %% "akka-http" % AkkaHttpVersion,
  "com.typesafe.akka" %% "akka-http-spray-json" % AkkaHttpVersion
)

libraryDependencies += "mysql" % "mysql-connector-java" % "8.0.23"

// Here, `libraryDependencies` is a set of dependencies, and by using `+=`,
// we're adding the scala-parser-combinators dependency to the set of dependencies
// that sbt will go and fetch when it starts up.
// Now, in any Scala file, you can import classes, objects, etc., from
// scala-parser-combinators with a regular import.

// TIP: To find the "dependency" that you need to add to the
// `libraryDependencies` set, which in the above example looks like this:

// "org.scala-lang.modules" %% "scala-parser-combinators" % "1.1.2"

// You can use Scaladex, an index of all known published Scala libraries. There,
// after you find the library you want, you can just copy/paste the dependency
// information that you need into your build file. For example, on the
// scala/scala-parser-combinators Scaladex page,
// https://index.scala-lang.org/scala/scala-parser-combinators, you can copy/paste
// the sbt dependency from the sbt box on the right-hand side of the screen.

// IMPORTANT NOTE: while build files look _kind of_ like regular Scala, it's
// important to note that syntax in *.sbt files doesn't always behave like
// regular Scala. For example, notice in this build file that it's not required
// to put our settings into an enclosing object or class. Always remember that
// sbt is a bit different, semantically, than vanilla Scala.

// ============================================================================

// Most moderately interesting Scala projects don't make use of the very simple
// build file style (called "bare style") used in this build.sbt file. Most
// intermediate Scala projects make use of so-called "multi-project" builds. A
// multi-project build makes it possible to have different folders which sbt can
// be configured differently for. That is, you may wish to have different
// dependencies or different testing frameworks defined for different parts of
// your codebase. Multi-project builds make this possible.

// Here's a quick glimpse of what a multi-project build looks like for this
// build, with only one "subproject" defined, called `root`:

// lazy val root = (project in file(".")).
//   settings(
//     inThisBuild(List(
//       organization := "ch.epfl.scala",
//       scalaVersion := "2.13.3"
//     )),
//     name := "hello-world"
//   )

// To learn more about multi-project builds, head over to the official sbt
// documentation at http://www.scala-sbt.org/documentation.html

[0m2021.03.20 23:26:54 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
[0m2021.03.20 23:27:10 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              userBase.toJson.toString()
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:28:19 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}


object ScalaJdbcConnectSelect extends App {
    // connect to the database named "mysql" on port 8889 of localhost
    val url = "jdbc:mysql://localhost:3309/classicmodels"
    val driver = "com.mysql.jdbc.Driver"
    val username = "demo"
    val password = "123"
    var connection:Connection = _
    try {
        Class.forName(driver)
        connection = DriverManager.getConnection(url, username, password)
        val statement = connection.createStatement
        val rs = statement.executeQuery("SELECT * FROM customers")
        while (rs.next) {
            val host = rs.getString("host")
            val user = rs.getString("user")
            println("host = %s, user = %s".format(host,user))
        }
    } catch {
        case e: Exception => e.printStackTrace
    }
    connection.close
}

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              userBase.toJson.toString()
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:32:04 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def main(args: Array[String]) {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val host = resultSet.getString("host")
        val user = resultSet.getString("user")
        println("host, user = " + host + ", " + user)
      }
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              userBase.toJson.toString()
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

MÃ¤rz 20, 2021 11:32:44 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 37360
[0m2021.03.20 23:33:20 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def main(args: Array[String]) {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        println("customerNumber, customerName = " + customerNumber + ", " + customerName)
      }
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

case class User(name: String, age: Int)

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              userBase.toJson.toString()
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

MÃ¤rz 20, 2021 11:34:08 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 37651
MÃ¤rz 20, 2021 11:37:28 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 38640
MÃ¤rz 20, 2021 11:38:27 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 38954
[0m2021.03.20 23:40:39 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(args: Array[String]) {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = List()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        (customerName, customerNumber) :: customerList
      }
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

case class User(name: String, age: Int)

case class Customer(customerNumber: Int, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerName, customerNumber.toInt)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              userBase.toJson.toString()
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:41:28 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(args: Array[String]) {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = List()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        val customer = (customerName, customerNumber) :: customerList
      }
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

case class User(name: String, age: Int)

case class Customer(customerNumber: Int, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerName, customerNumber.toInt)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              userBase.toJson.toString()
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:41:51 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(args: Array[String]) {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = List()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        val customer = (customerName, customerNumber) :: customerList
      }
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

case class User(name: String, age: Int)

case class Customer(customerNumber: Int, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerName, customerNumber)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              userBase.toJson.toString()
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:42:40 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(args: Array[String]) {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = List()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        val customer = (customerName, customerNumber) :: customerList
      }
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

case class User(name: String, age: Int)

case class Customer(customerNumber: Int, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              userBase.toJson.toString()
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:43:04 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(args: Array[String]) {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = List()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        val customer = (customerName, customerNumber) :: customerList
      }
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

case class User(name: String, age: Int)

case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              userBase.toJson.toString()
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:45:27 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(args: Array[String]) {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = List()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        val customer = (customerName, customerNumber) :: customerList
      }
      return customerList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

case class User(name: String, age: Int)

case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              userBase.toJson.toString()
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:45:58 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(args: Array[String]) {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = List()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        val customer = (customerName, customerNumber) :: customerList
      }
      return customerList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              userBase.toJson.toString()
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:46:31 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(args: Array[String]) {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = List()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        val customer = (customerName, customerNumber) :: customerList
      }
      return customerList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              userBase.toJson
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

MÃ¤rz 20, 2021 11:47:05 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 40040
[0m2021.03.20 23:47:35 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(args: Array[String]) {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = List()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        val customer = (customerName, customerNumber) :: customerList
      }
      return customerList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase = ScalaJdbcConnectSelect.getDataFromDb()

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              userBase.toJson
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:47:55 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb() {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = List()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        val customer = (customerName, customerNumber) :: customerList
      }
      return customerList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase = ScalaJdbcConnectSelect.getDataFromDb()

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              userBase.toJson
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:48:17 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb() {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = List()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        val customer = (customerName, customerNumber) :: customerList
      }
      return customerList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase = ScalaJdbcConnectSelect.getDataFromDb()

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toJson
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:49:13 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb() {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = List()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        val customer = (customerName, customerNumber) :: customerList
      }
      return customerList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase = ScalaJdbcConnectSelect.getDataFromDb()
    println(customerBase)

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toJson
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:49:25 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb() {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = List()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        val customer = (customerName, customerNumber) :: customerList
      }
      return customerList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase = ScalaJdbcConnectSelect.getDataFromDb()
    println(customerBase)

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toString
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:49:55 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb() {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = List()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        val customer = (customerName, customerNumber) :: customerList
      }
      return customerList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase = ScalaJdbcConnectSelect.getDataFromDb()
    println(customerBase)

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toString
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  /*val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)*/

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)
  // yield (i, j)

  foo(10, 10) /* foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:50:37 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb() {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = List()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        val customer = (customerName, customerNumber) :: customerList
      }
      return customerList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase = ScalaJdbcConnectSelect.getDataFromDb()
    println(customerBase)

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toString
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  /*val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)*/

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  /*def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)*/
  // yield (i, j)

  /*foo(10, 10) // foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

MÃ¤rz 20, 2021 11:51:56 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: Cannot invoke "scala.reflect.internal.Types$Type.decls()" because the return value of "scala.reflect.internal.Trees$Tree.tpe()" is null
MÃ¤rz 20, 2021 11:51:58 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: Cannot invoke "scala.reflect.internal.Types$Type.decls()" because the return value of "scala.reflect.internal.Trees$Tree.tpe()" is null
MÃ¤rz 20, 2021 11:52:00 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: Cannot invoke "scala.reflect.internal.Types$Type.decls()" because the return value of "scala.reflect.internal.Trees$Tree.tpe()" is null
[0m2021.03.20 23:52:41 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb() {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = List<Customer>()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        val customer = (customerName, customerNumber) :: customerList
      }
      return customerList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase = ScalaJdbcConnectSelect.getDataFromDb()
    println(customerBase)

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toString
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  /*val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)*/

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  /*def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)*/
  // yield (i, j)

  /*foo(10, 10) // foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

MÃ¤rz 20, 2021 11:53:11 PM scala.meta.internal.pc.CompletionProvider expected$1
WARNING: Cannot invoke "scala.reflect.internal.Types$Type.decls()" because the return value of "scala.reflect.internal.Trees$Tree.tpe()" is null
[0m2021.03.20 23:53:30 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(): List[Customer] = {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = List<Customer>()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        val customer = (customerName, customerNumber) :: customerList
      }
      return customerList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase = ScalaJdbcConnectSelect.getDataFromDb()
    println(customerBase)

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toString
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  /*val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)*/

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  /*def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)*/
  // yield (i, j)

  /*foo(10, 10) // foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

MÃ¤rz 20, 2021 11:54:19 PM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleCancellation
WARNING: Unmatched cancel notification for request id 40921
[0m2021.03.20 23:54:24 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(): List[Customer] = {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = List()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        val customer = (customerName, customerNumber) :: customerList
      }
      return customerList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase = ScalaJdbcConnectSelect.getDataFromDb()
    println(customerBase)

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toString
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  /*val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)*/

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  /*def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)*/
  // yield (i, j)

  /*foo(10, 10) // foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

something's wrong: no file:///home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala in () => <error>RangePosition(file:///home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala, 1015, 1071, 1862)
[0m2021.03.20 23:55:31 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(): List[Customer] = {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = List[Customer]()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        val customer = (customerName, customerNumber) :: customerList
      }
      return customerList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase = ScalaJdbcConnectSelect.getDataFromDb()
    println(customerBase)

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toString
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  /*val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)*/

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  /*def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)*/
  // yield (i, j)

  /*foo(10, 10) // foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:55:49 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(): List[Customer] | Nothing = {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = List[Customer]()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        val customer = (customerName, customerNumber) :: customerList
      }
      return customerList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase = ScalaJdbcConnectSelect.getDataFromDb()
    println(customerBase)

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toString
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  /*val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)*/

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  /*def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)*/
  // yield (i, j)

  /*foo(10, 10) // foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:56:14 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(): List[Customer] = {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = List[Customer]()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        val customer = (customerName, customerNumber) :: customerList
      }
      return customerList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
    return customerList
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase = ScalaJdbcConnectSelect.getDataFromDb()
    println(customerBase)

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toString
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  /*val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)*/

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  /*def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)*/
  // yield (i, j)

  /*foo(10, 10) // foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:58:26 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import scala.collection.mutable.ListBuffer

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(): List[Customer] = {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = new ListBuffer[Customer]()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        customerList += Customer(customerNumber, customerName)
      }
      return customerList.toList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
    return customerList.toList
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase = ScalaJdbcConnectSelect.getDataFromDb()
    println(customerBase)

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toString
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  /*val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)*/

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  /*def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)*/
  // yield (i, j)

  /*foo(10, 10) // foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:58:45 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import scala.collection.mutable.ListBuffer

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(): List[Customer] = {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = new ListBuffer[Customer]()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        customerList += Customer(customerName, customerNumber)
      }
      return customerList.toList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
    return customerList.toList
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase = ScalaJdbcConnectSelect.getDataFromDb()
    println(customerBase)

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toString
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  /*val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)*/

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  /*def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)*/
  // yield (i, j)

  /*foo(10, 10) // foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:59:02 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import scala.collection.mutable.ListBuffer

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(): List[Customer] = {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = new ListBuffer[Customer]()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        customerList += Customer(customerNumber, customerName)
      }
      return customerList.toList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
    return customerList.toList
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase = ScalaJdbcConnectSelect.getDataFromDb()
    println(customerBase)

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toString
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  /*val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)*/

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  /*def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)*/
  // yield (i, j)

  /*foo(10, 10) // foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:59:21 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import scala.collection.mutable.ListBuffer

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(): List[Customer] = {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = new ListBuffer[Customer]()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        customerList += Customer(customerNumber = customerNumber, customerName = customerName)
      }
      return customerList.toList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
    return customerList.toList
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase = ScalaJdbcConnectSelect.getDataFromDb()
    println(customerBase)

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toString
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  /*val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)*/

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  /*def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)*/
  // yield (i, j)

  /*foo(10, 10) // foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.20 23:59:45 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import scala.collection.mutable.ListBuffer

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(): List[Customer] = {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = new ListBuffer[Customer]()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        customerList += Customer(customerNumber = customerNumber, customerName = customerName)
      }
      return customerList.toList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
    return customerList.toList
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: Int, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase = ScalaJdbcConnectSelect.getDataFromDb()
    println(customerBase)

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toString
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  /*val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)*/

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  /*def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)*/
  // yield (i, j)

  /*foo(10, 10) // foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.21 00:00:14 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import scala.collection.mutable.ListBuffer

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(): List[Customer] = {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = new ListBuffer[Customer]()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getString("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        customerList += Customer(customerName, customerName)
      }
      return customerList.toList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
    return customerList.toList
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: Int, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase = ScalaJdbcConnectSelect.getDataFromDb()
    println(customerBase)

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toString
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  /*val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)*/

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  /*def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)*/
  // yield (i, j)

  /*foo(10, 10) // foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.21 00:00:31 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import scala.collection.mutable.ListBuffer

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(): List[Customer] = {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = new ListBuffer[Customer]()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getInt("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        customerList += Customer(customerName, customerName)
      }
      return customerList.toList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
    return customerList.toList
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: Int, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase = ScalaJdbcConnectSelect.getDataFromDb()
    println(customerBase)

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toString
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  /*val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)*/

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  /*def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)*/
  // yield (i, j)

  /*foo(10, 10) // foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.21 00:01:07 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import scala.collection.mutable.ListBuffer

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(): List[Customer] = {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = new ListBuffer[Customer]()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getInt("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        customerList += Customer(customerNumber, customerName)
      }
      return customerList.toList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
    return customerList.toList
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: Int, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase = ScalaJdbcConnectSelect.getDataFromDb()
    println(customerBase)

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toString
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  /*val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)*/

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  /*def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)*/
  // yield (i, j)

  /*foo(10, 10) // foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.21 00:01:23 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import scala.collection.mutable.ListBuffer

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(): List[Customer] = {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = new ListBuffer[Customer]()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getBigDecimal("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        customerList += Customer(customerNumber, customerName)
      }
      return customerList.toList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
    return customerList.toList
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: Int, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase = ScalaJdbcConnectSelect.getDataFromDb()
    println(customerBase)

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toString
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  /*val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)*/

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  /*def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)*/
  // yield (i, j)

  /*foo(10, 10) // foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.21 00:01:32 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import scala.collection.mutable.ListBuffer

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(): List[Customer] = {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = new ListBuffer[Customer]()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getBigDecimal("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        customerList += Customer(customerNumber, customerName)
      }
      return customerList.toList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
    return customerList.toList
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase = ScalaJdbcConnectSelect.getDataFromDb()
    println(customerBase)

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toString
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  /*val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)*/

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  /*def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)*/
  // yield (i, j)

  /*foo(10, 10) // foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.21 00:02:22 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import scala.collection.mutable.ListBuffer

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(): List[Customer] = {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = new ListBuffer[Customer]()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getBigDecimal("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        customerList += Customer(customerNumber, customerName)
      }
      return customerList.toList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
    return customerList.toList
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase = ScalaJdbcConnectSelect.getDataFromDb()
    println(customerBase)

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toJson
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  /*val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)*/

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  /*def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)*/
  // yield (i, j)

  /*foo(10, 10) // foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.21 00:02:44 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import scala.collection.mutable.ListBuffer

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(): List[Customer] = {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = new ListBuffer[Customer]()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getBigDecimal("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        customerList += Customer(customerNumber, customerName)
      }
      return customerList.toList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
    return customerList.toList
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase = ScalaJdbcConnectSelect.getDataFromDb()

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toJson
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  /*val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)*/

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  /*def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)*/
  // yield (i, j)

  /*foo(10, 10) // foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

something's wrong: no file:///home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala in List[<error>]RangePosition(file:///home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala, 3754, 3754, 3768)
something's wrong: no file:///home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala in List[<error>]RangePosition(file:///home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala, 3754, 3754, 3801)
something's wrong: no file:///home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala in List[<error>]RangePosition(file:///home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala, 3754, 3754, 3768)
something's wrong: no file:///home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala in List[C]RangePosition(file:///home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala, 3754, 3754, 3761)
something's wrong: no file:///home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala in List[<error>]RangePosition(file:///home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala, 3754, 3754, 3764)
something's wrong: no file:///home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala in List[Customer]RangePosition(file:///home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala, 3754, 3754, 3768)
[0m2021.03.21 00:03:08 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import scala.collection.mutable.ListBuffer

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(): List[Customer] = {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = new ListBuffer[Customer]()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getBigDecimal("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        customerList += Customer(customerNumber, customerName)
      }
      return customerList.toList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
    return customerList.toList
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase: List[Customer] = ScalaJdbcConnectSelect.getDataFromDb()

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toJson
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  /*val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)*/

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  /*def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)*/
  // yield (i, j)

  /*foo(10, 10) // foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.21 00:04:18 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import scala.collection.mutable.ListBuffer

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(): List[Customer] = {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = new ListBuffer[Customer]()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getBigDecimal("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        customerList += Customer(customerNumber, customerName)
      }
      return customerList.toList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
    return customerList.toList
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

/*object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}*/

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase: List[Customer] = ScalaJdbcConnectSelect.getDataFromDb()

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toJson
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  /*val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)*/

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  /*def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)*/
  // yield (i, j)

  /*foo(10, 10) // foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

[0m2021.03.21 00:04:39 WARN  no build target for: /home/nevermind/scalademo/hello-world-template/src/main/scala/Main.scala[0m
import scala.collection.mutable.ArrayBuffer
import scala.math._
import scala.util.Random

import scala.collection.mutable.ListBuffer

// https://doc.akka.io/docs/akka-http/current/index.html
import akka.actor.typed.ActorSystem
import akka.actor.typed.scaladsl.Behaviors
import akka.http.scaladsl.Http
import akka.http.scaladsl.model._
import akka.http.scaladsl.server.Directives._
import scala.io.StdIn

import spray.json._
import akka.http.scaladsl.marshallers.sprayjson.SprayJsonSupport._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._

import java.sql.{Connection,DriverManager}

/**
 * A Scala JDBC connection example by Alvin Alexander,
 * https://alvinalexander.com
 */
object ScalaJdbcConnectSelect {

  def getDataFromDb(): List[Customer] = {
    // connect to the database named "mysql" on the localhost
    val driver = "com.mysql.cj.jdbc.Driver"
    val url = "jdbc:mysql://localhost/classicmodels"
    val username = "demo"
    val password = "123"

    val customerList = new ListBuffer[Customer]()

    // there's probably a better way to do this
    var connection:Connection = null

    try {
      // make the connection
      Class.forName(driver)
      connection = DriverManager.getConnection(url, username, password)

      // create the statement, and run the select query
      val statement = connection.createStatement()
      val resultSet = statement.executeQuery("SELECT * FROM customers")
      while ( resultSet.next() ) {
        val customerNumber = resultSet.getBigDecimal("customerNumber")
        val customerName = resultSet.getString("customerName")
        // println("customerNumber, customerName = " + customerNumber + ", " + customerName)
        customerList += Customer(customerNumber, customerName)
      }
      return customerList.toList
    } catch {
      case e => e.printStackTrace
    }
    connection.close()
    return customerList.toList
  }

}

case class User(name: String, age: Int)
case class Customer(customerNumber: BigDecimal, customerName: String)

object MyCustomerJsonProtocol extends DefaultJsonProtocol {
  implicit object CustomerJsonFormat extends RootJsonFormat[Customer] {
    def write(c: Customer) =
      JsArray(
        JsString(c.customerName),
        JsNumber(c.customerNumber)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(customerName),
              JsNumber(customerNumber)
            )
          ) =>
        new Customer(customerNumber, customerName)
      case _ => deserializationError("Customer not found")
    }
  }
}

/*object MyUserJsonProtocol extends DefaultJsonProtocol {
  implicit object UserJsonFormat extends RootJsonFormat[User] {
    def write(c: User) =
      JsArray(
        JsString(c.name),
        JsNumber(c.age)
      )

    def read(value: JsValue) = value match {
      case JsArray(
            Vector(
              JsString(name),
              JsNumber(age)
            )
          ) =>
        new User(name, age.toInt)
      case _ => deserializationError("Color expected")
    }
  }
}*/

// import spray.json._
// import DefaultJsonProtocol._ // if you don't supply your own Protocol (see below)
// import MyUserJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...
import MyCustomerJsonProtocol._ // we need to import our own protocol eventhough we are in the same file...

// base webserver to serve up stuff, lets say, json
object HttpServerRoutingMinimal {

  def main(args: Array[String]): Unit = {

    /*val userBase = List(
      User("Travis", 28),
      User("Kelly", 33),
      User("Jennifer", 44),
      User("Dennis", 23)
    )*/

    val customerBase: List[Customer] = ScalaJdbcConnectSelect.getDataFromDb()

    implicit val system = ActorSystem(Behaviors.empty, "my-system")
    // needed for the future flatMap/onComplete in the end
    implicit val executionContext = system.executionContext

    val route =
      path("hello") {
        get {
          complete(
            HttpEntity(
              ContentTypes.`application/json`,
              customerBase.toJson.toString()
            )
          )
        }
      }

    val bindingFuture = Http().newServerAt("0.0.0.0", 8080).bind(route)

    println(
      s"Server online at http://scala.localnet:8080/\nPress RETURN to stop..."
    )
    StdIn.readLine() // let it run until user presses return
    bindingFuture
      .flatMap(_.unbind()) // trigger unbinding from the port
      .onComplete(_ => system.terminate()) // and shutdown when done
  }
}


object CustomerID {

  def apply(name: String) = s"$name--${Random.nextLong}"

  def unapply(customerID: String): Option[String] = {
    val stringArray: Array[String] = customerID.split("--")
    if (stringArray.tail.nonEmpty) Some(stringArray.head) else None
  }
}

class Email(val username: String, val domainName: String)

object Email {
  def fromString(emailString: String): Option[Email] = {
    emailString.split('@') match {
      case Array(a, b) => Some(new Email(a, b))
      case _           => None
    }
  }
}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) =
    temp * 1.8 + 32 // local funct with the conversion
  def forecastInFahrenheit: Seq[Double] =
    temperatures.map(convertCtoF) // <-- passing the method convertCtoF
}

abstract class AbsIterator {
  type T // generic type t
  def hasNext: Boolean //nextval true or false, if next false, lastval
  def next(): T // generic type t, its gonna be a char (counting single chars in string) anywho, could be ... a type
}

// the actual iterator extending the base class absiterator...
class StringIterator(s: String) extends AbsIterator {
  type T = Char // set type to char
  private var i = 0 // local iterator var
  def hasNext =
    i < s.length // our hasnext boolean dynamically from the iteration
  def next() = { // the next function that outputs a char
    val ch =
      s charAt i // s search? charAt (character at position?) i would be our iterator
    i += 1 // iterator iterating...
    ch // output the singlechar "to be println'd"
  }
}

// the trait for later use in main, i think
trait RichIterator extends AbsIterator {
  // our foreach "override", works on the given string f
  def foreach(f: T => Unit): Unit = while (hasNext) f(next())
}

// there we go, our class definition for the call ("Scala" being characterized)
class RichStringIter extends StringIterator("Scala") with RichIterator

abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

trait Pet {
  val name: String // public var "name" for direct access from println in main
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

trait Interface {
  def operation(adjust: Int): Int;
}

trait PointMagic[A, B] {
  def x: B;
  def y: B;
  def runmagic(): A;
}

object MyDummyObject {
  def construct(someVal: Int): Interface = {
    class Impl(var current: Int) extends Interface {
      def operation(adjust: Int): Int = {
        current += adjust
        return current
      }
    }
    var myImpl = new Impl(someVal)
    return myImpl
  }
}

object MyDummyPoint {
  def construct(x: Int, y: Int): PointMagic[String, Int] = {
    var myPoint = new Point(x, y)
    return myPoint
  }
}

class Point(var x: Int, var y: Int) extends PointMagic[String, Int] {
  /*private var _x = 0
  private var _y = 0*/
  private val bound = 100 // 100 is hard boundary

  /*def x = x_
  def y = y_*/

  /*def x_=(valX: Int): Unit = { setCoordinates(valX, y) }
  def y_=(valY: Int): Unit = { setCoordinates(x, valY) }

  def setCoordinates(val1: Int, val2: Int) {
    if (val1 < bound && val2 < bound) printf("val1: %s, val2: %s\n", val1, val2)
    else printWarning
  }*/

  def Point(newX: Int, newY: Int) {
    println("we are running on auto")
  }

  override def runmagic(): String = {
    // var newX: String = x.toString
    return f"x: $x%s, y: $y%s"
  }

  /*def x = _x // gets the x provided
  def x_=(newValue: Int): Unit = { // boundary checker...
    // if (newValue < bound) _x = newValue else printWarning
    setCoordinates(newValue, 0)
  }*/

  /*def y = _y
  def y_=(newValue: Int): Unit = { // second boundary checker...
    // if (newValue < bound) _y = newValue else printWarning
    setCoordinates(0, newValue)
  }*/

  private def printWarning = println("WARNING: Out of bounds")
}

/*class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}*/

/*class Greeter(prefix: String, suffix: String) {
  def greet(name: String): Unit =
    println(prefix + name + suffix)
}*/

trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter // has everything of greeter trait...

// overrides greeter trait functionality
class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

class UrlBuilder(var ssl: Boolean, var domainName: String) {
  def urlBuilder(): (String, String) => String = {
    val schema = if (ssl) "https://" else "http://"
    (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
  }
}

// will a command start a rebuild?, yes
object MyMain/* extends App*/ {
  // println("""|Hello, Austria!""".stripMargin)
  // println(200 + 1000000)

  // def name: String = System.getProperty("""|user.name""".stripMargin)
  // println("""|Hello, """.stripMargin + name + "!")

  /*val greeter = new Greeter("""|Hello, """.stripMargin, "!")
  greeter.greet("""|Scala developer""".stripMargin)*/

  // val greeter = new DefaultGreeter()
  // greeter.greet("Scala developer") // Hello, Scala developer!

  // val customGreeter = new CustomizableGreeter("How are you, ", "?")
  // customGreeter.greet("Scala developer") // How are you, Scala developer?

  /*val list: List[Any] = List(
    "a string",
    732, // an integer
    'c', // a character
    true, // a boolean value
    () => "an anonymous function returning a string"
  )

  list.foreach(element => println(element))

  val x: Long = 987654321
  val y: Float =
    x // 9.8765434E8 (note that some precision is lost in this case)

  val face: Char = 'âº'
  val number: Int = face // 9786*/

  /*val point1 = new Point(2, 3)
  point1.move(2, 6) // actually move around
  println(point1.x) // 2
  println(point1) // prints (2, 3)*/
  // val point1 =
  //  new Point() // class call with default constructor values and without an ()
  // point1.x = 50 // sets the x coordinate
  // point1.y = 70 // prints the warning
  // point1.checkBoundaries
  // point1(100, 99)

  // var dummyObject = MyDummyObject.construct(200)
  // println(dummyObject.operation(1000))

  // var dummyPoint = MyDummyPoint.construct(100, 200) // add vals
  // println(dummyPoint.runmagic()) // return something... lets check the val content

  // create items of obj
  /*val dog = new Dog("Harry")
  val cat = new Cat("Sally")*/

  // create an empty array of type Pet
  // val animals = ArrayBuffer.empty[Pet]

  // add our pet items to the pet array
  /*animals.append(dog)
  animals.append(cat)*/

  // animals.foreach(pet => println(pet.name)) // Prints Harry Sally (item.name prop)

  /*val planets =
    List(
      ("Mercury", 57.9),
      ("Venus", 108.2),
      ("Earth", 149.6),
      ("Mars", 227.9),
      ("Jupiter", 778.3)
    ) // end of val planets definition*/

  // start of val planets operation
  /*planets.foreach {
    case ("Earth", distance) =>
      println(s"Our planet is $distance million kilometers from the sun")
    case _ => println("not our planet") // switch case default:
  }*/

  /** would be someArray.forEach((item, idx) => { switch(item.prop) { case1: doseomething, break casN..., default: } })
    */

  /*val numPairs = List((2, 5), (3, -7), (20, 56))
  for ((a, b) <- numPairs) { // for ((let a, let b) in numPairs) ... maybe: numPairs...toarraythingy.map((a, b)...)
    println(a * b)
  }*/

  /*val d = new D // d takes from b with uppercase from c
  println(d.message) // I'm an instance of class B
  println(d.loudMessage) // I'M AN INSTANCE OF CLASS B*/

  /*val richStringIter = new RichStringIter
  richStringIter.foreach(println)*/

  val salaries = Seq(20000, 70000, 40000)
  salaries.map(_ * 2).foreach(println)

  /*var temperature = WeeklyWeatherForecast(Seq(-05.00, 10.00, 28.50, 35.50))
  temperature.forecastInFahrenheit.map(println(_))*/

  /** class urlBuilder (ssl: Boolean, domainName: String) {
    *  def urlBuilder(): (String, String) => String = {
    */
  /*val domainName = "www.example.com"
  def getURL = new UrlBuilder(true, domainName).urlBuilder()
  val endpoint = "users"
  val query = "id=1"
  val url =
    getURL(endpoint, query) // "https://www.example.com/users?id=1": String
  println(url)*/

  /*val circle1 = Circle(5.0)
  println(circle1.area)*/

  val scalaCenterEmail = Email.fromString("scala.center@epfl.ch")
  scalaCenterEmail match {
    case Some(email) => println(s"""Registered an email
       |Username: ${email.username}
       |Domain name: ${email.domainName}
     """.stripMargin)
    case None        => println("Error: could not parse email")
  }

  val customer1ID = CustomerID("Sukyoung") // Sukyoung--23098234908
  customer1ID match {
    case CustomerID(name) => println(name) // prints Sukyoung
    case _                => println("Could not extract a CustomerID")
  }

  val customer2ID = CustomerID(
    "TEST--asdfasdfasdf"
  ) // new value "Nico" being operated on applied...
  val CustomerID(name) =
    customer2ID // the "name" in customerid becomes customer2id
  println(name) // prints customerid name (applied)

  /*val userBase = List(
    User("Travis", 28),
    User("Kelly", 33),
    User("Jennifer", 44),
    User("Dennis", 23)
  )

  println(userBase.toJson)*/

  /*val twentySomethings =
    for (user <- userBase if user.age >= 20 && user.age < 30)
      yield user.name // i.e. add this to a list

  twentySomethings.foreach(println) // prints Travis Dennis*/

  /*def foo(n: Int, v: Int) =
    for (
      i <- 0 until n;
      j <- 0 until n if i + j == v
    )
      println(s"($i, $j)".toJson)*/
  // yield (i, j)

  /*foo(10, 10) // foreach { case (i, j) =>
    println(
      s"($i, $j) "
    ) // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
  }*/
}

MÃ¤rz 21, 2021 12:06:57 AM org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint notify
INFO: Unsupported notification method: $/setTraceNotification
MÃ¤rz 21, 2021 12:07:20 AM org.eclipse.lsp4j.jsonrpc.RemoteEndpoint handleNotification
WARNING: Notification threw an exception: {
  "jsonrpc": "2.0",
  "method": "metals/didFocusTextDocument",
  "params": "git:/home/nevermind/scalademo/.metals/readonly/java.base/java/lang/System.java?%7B%22path%22%3A%22%2Fhome%2Fnevermind%2Fscalademo%2F.metals%2Freadonly%2Fjava.base%2Fjava%2Flang%2FSystem.java%22%2C%22ref%22%3A%22%22%7D"
}
java.lang.RuntimeException: java.lang.reflect.InvocationTargetException
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:67)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.notify(GenericEndpoint.java:152)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.handleNotification(RemoteEndpoint.java:220)
	at org.eclipse.lsp4j.jsonrpc.RemoteEndpoint.consume(RemoteEndpoint.java:187)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.handleMessage(StreamMessageProducer.java:194)
	at org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer.listen(StreamMessageProducer.java:94)
	at org.eclipse.lsp4j.jsonrpc.json.ConcurrentMessageProcessor.run(ConcurrentMessageProcessor.java:113)
	at java.base/java.util.concurrent.Executors$RunnableAdapter.call(Executors.java:515)
	at java.base/java.util.concurrent.FutureTask.run(FutureTask.java:264)
	at java.base/java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1130)
	at java.base/java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:630)
	at java.base/java.lang.Thread.run(Thread.java:831)
Caused by: java.lang.reflect.InvocationTargetException
	at jdk.internal.reflect.GeneratedMethodAccessor19.invoke(Unknown Source)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:567)
	at org.eclipse.lsp4j.jsonrpc.services.GenericEndpoint.lambda$null$0(GenericEndpoint.java:65)
	... 11 more
Caused by: java.nio.file.FileSystemNotFoundException: Provider "git" not installed
	at java.base/java.nio.file.Path.of(Path.java:212)
	at java.base/java.nio.file.Paths.get(Paths.java:98)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:445)
	at scala.meta.internal.metals.MetalsEnrichments$XtensionString.toAbsolutePath(MetalsEnrichments.scala:442)
	at scala.meta.internal.metals.MetalsLanguageServer.didFocus(MetalsLanguageServer.scala:982)
	... 15 more

